# 携程测开秋招（2面）面经解析

[TOC]

## 二面

### 1. 自我介绍

> **注意：** 此部分为个人化内容，请根据您的实际情况准备。

### 2. 实习主要做的是硬件测试为什么想转软件测试？

> **注意：** 此部分为个人化内容，请根据您的职业规划和思考进行回答。核心是表达你对软件测试的热情、你认为自己具备的优势，以及你为此做出的努力。

### 3. 讲讲测试的整个流程

**简短回答 (50-70分):**

**面试官您好，我理解的测试流程是一个贯穿整个软件开发生命周期的闭环过程。** 它大致分为四个阶段：首先是需求分析与计划阶段，我们会评审需求并制定测试策略；然后是测试设计与开发阶段，编写测试用例和自动化脚本；接着是测试执行阶段，在新版本上执行测试并提交Bug；最后是回归测试与报告阶段，验证Bug修复情况并输出测试报告，对整个过程进行复盘。

**深度回答:**

**面试官您好，在我参与的项目中，我们遵循的是一套融入敏捷开发模式的、完整的V模型测试流程。这个流程确保了测试活动在开发周期的早期就介入，并贯穿始终。**

我可以将其分解为以下几个关键阶段：

*   **第一阶段：需求分析与测试计划**
    *   **需求评审：** 我们测试人员会和产品、开发一起参加需求评审会。在这个阶段，我的主要任务是从测试的角度出发，去发现需求文档中逻辑不清晰、存在歧义或遗漏异常场景的地方，提前暴露问题。
    *   **风险分析与测试策略制定：** 基于需求，我们会评估项目的技术风险和业务风险，然后确定本次迭代的测试范围、测试重点以及资源投入。比如，对于一个支付模块，我们会将其定义为最高优先级的测试对象，并投入更多的资源进行深入测试。
    *   **测试计划输出：** 最后会产出一份测试计划文档，明确测试目标、时间节点、人员安排和交付标准。

*   **第二阶段：测试设计与开发**
    *   **测试用例设计：** 这是将测试策略具体化的过程。我会使用像 **等价类、边界值、判定表、场景法** 等测试设计方法来编写测试用例，确保对业务逻辑的覆盖度。写好的用例会组织一次用例评审，让开发和产品都参与进来，确保我们对需求的理解是一致的。
    *   **自动化脚本开发：** 对于那些核心、稳定且需要重复执行的场景，我们会并行地开发自动化测试脚本。

*   **第三阶段：测试执行与缺陷管理**
    *   **环境准备与冒烟测试：** 在开发提测后，我们会先在测试环境部署新版本，然后执行一个核心用例集（冒烟测试），快速验证版本的主要功能是否可用。如果冒烟不通过，版本会被直接打回。
    *   **全面执行与缺陷跟踪：** 冒烟通过后，我们会系统地执行所有测试用例，包括功能测试、UI测试、接口测试等。发现的Bug会记录在JIRA这样的缺陷管理工具中，详细描述复现步骤、实际结果和期望结果，并指派给对应的开发人员。

*   **第四阶段：回归测试与上线评估**
    *   **回归测试：** 开发修复Bug后，会再次提测。我们会首先验证Bug是否被修复，然后对相关模块以及核心功能进行回归测试，确保修复没有引入新的问题（即所谓的“回归缺陷”）。
    *   **测试报告与上线决策：** 所有测试完成后，我们会出具一份详细的测试报告，内容包括测试了哪些功能、发现了多少Bug、Bug的修复情况、以及当前遗留的风险等，为最终版本能否上线提供关键的数据支持。
    *   **线上验证与复盘：** 版本上线后，我们会对生产环境进行一轮基本的线上验证（通常称为“生产环境冒烟”）。并且，每个迭代结束后，我们都会进行复盘，总结经验，持续优化我们的测试流程。

> **补充说明：**
> *   **左移（Shift-Left）：** 在回答中强调“测试早期介入”、“参加需求评审”，体现了“测试左移”的思想，这是现代软件测试的核心理念，能让面试官觉得你非常专业。
> *   **闭环（Closed-Loop）：** 强调流程的闭环，从需求到上线再到复盘，说明你对质量管理有体系化的思考，而不仅仅是“点点点”的执行者。
> *   **量化与工具：** 在描述中适当加入一些工具名称（如JIRA）和量化的概念（如Bug数量、风险评估），会让你的回答显得更真实、更有说服力。

### 4. 了不了解接口测试接口测试主要关注什么

**简短回答 (50-70分):**

**面试官您好，我非常了解接口测试，并且在项目中也有丰富的实践经验。** 我认为接口测试的核心是绕过前端页面，直接对后端服务的业务逻辑进行验证。我主要关注以下几点：首先是功能的正确性，即接口是否按文档要求返回了正确的数据；其次是异常处理能力，比如传入错误的参数，接口是否能返回合理的错误码和提示；最后是性能和安全，比如接口的响应时间和是否能抵御一些基本的安全攻击。

**深度回答:**

**面试官您好，我非常熟悉接口测试，它是我在项目中实践最多、认为投入产出比最高的一种测试方式。** 接口测试的本质是验证服务器端组件之间、以及客户端与服务器端之间的通信逻辑是否正确。在我看来，做好接口测试需要系统性地关注以下几个方面：

*   **1. 功能正确性验证 (Functionality):** 这是最基本也是最核心的关注点。
    *   **正常场景：** 我会根据接口文档，构造合法的输入参数，然后验证返回的数据是否与预期结果完全一致。比如，一个查询用户信息的接口，我会验证返回的用户名、年龄等字段是否正确。
    *   **业务逻辑覆盖：** 我会使用 **等价类划分、边界值分析** 等方法，设计不同的输入组合，来验证接口是否正确处理了各种业务规则。例如，一个创建订单的接口，我会测试购买1件商品、购买库存上限的商品、以及使用不同优惠券组合等场景。

*   **2. 异常处理能力验证 (Exception Handling):** 一个健壮的系统必须能优雅地处理各种异常情况。
    *   **参数异常：** 我会测试各种非法的参数输入，例如：必填项不填、参数类型错误（如数字传字符串）、参数长度超长、包含特殊字符或SQL注入脚本等，然后验证接口是否返回了明确的错误码（如400 Bad Request）和友好的错误提示。
    *   **权限异常：** 我会测试无权限的用户（如未登录用户）或权限不足的用户（如普通用户尝试调用管理员接口）访问接口时，系统是否能正确拦截并返回相应的权限错误码（如401 Unauthorized 或 403 Forbidden）。
    *   **业务逻辑异常：** 我会测试一些违反业务规则的操作，比如对一个不存在的订单进行支付，或者重复提交同一个创建请求，看系统是否做了幂等性处理。

*   **3. 性能与安全性验证 (Performance & Security):**
    *   **性能方面：** 我会关注接口的 **响应时间（RT）** 和 **并发处理能力（QPS）**。虽然这属于性能测试的范畴，但在接口测试阶段，我就会对核心接口的响应时间做一个基本的判断，如果一个简单查询的接口响应时间超过1秒，我就会认为可能存在性能问题，并提前预警。
    *   **安全方面：** 我会进行一些基本的安全测试，比如检查敏感信息（如密码、身份证号）在传输过程中是否被加密，以及检查接口是否存在越权漏洞（比如用户A能否通过修改ID来查询到用户B的信息）。

*   **4. 协议与规范验证 (Protocol):**
    *   我还会检查接口的实现是否遵循了团队的API规范，比如URL的命名风格、HTTP请求方法的使用（GET/POST/PUT/DELETE）、返回JSON的结构是否统一等。这对于保证整个系统API的一致性和可维护性非常重要。

> **补充说明：**
> *   **结构化回答：** 将关注点归纳为“功能、异常、性能安全、规范”四大类，会让你的回答非常有条理，逻辑清晰。
> *   **举例说明：** 在每个关注点下，都举一个具体的例子（比如参数异常测什么，权限异常测什么），会让你的描述更生动、更具体，而不是空谈理论。
> *   **超越功能：** 不仅仅停留在功能层面，还能主动提到性能、安全、规范等更高阶的关注点，是体现你测试思维深度和广度的关键，也是区别于初级测试工程师的重要标志。

### 5. 接口测试过程中可能会出现哪些异常

**简短回答 (50-70分):**

**面试官您好，接口测试中可能出现的异常可以分为几大类。** 从客户端角度看，可能是请求参数错误，比如必填项为空、格式不正确。从服务端角度看，可能是服务器内部错误，比如空指针、数据库连接失败。从网络层面看，可能会有超时、连接被拒。此外，还有业务逻辑相关的异常，比如权限不足、资源不存在等。

**深度回答:**

**面试官您好，在接口测试的实践中，我总结了可能会遇到的异常，并将其归纳为“输入端”、“服务端”、“依赖端”和“业务逻辑”四个维度。**

*   **1. 输入端异常（客户端请求问题）：** 这类异常主要是由于客户端发送的请求不符合规范导致的。
    *   **参数缺失：** 必传的参数没有传递。
    *   **参数类型或格式错误：** 比如需要数字类型却传了字符串，需要日期格式`YYYY-MM-DD`却传了`YYYY/MM/DD`。
    *   **参数值域或长度越界：** 比如年龄传了200，或者用户名长度超过了数据库字段限制。
    *   **非法字符：** 参数中包含了SQL、XSS等攻击性脚本或特殊字符。
    *   **请求方法错误：** 比如一个需要POST方法的接口，却使用了GET方法去请求。

*   **2. 服务端异常（服务器内部问题）：** 这类异常是服务器自身处理请求时发生的内部错误。
    *   **服务器宕机或无响应：** 导致连接超时或连接被拒绝。
    *   **5xx内部服务器错误：** 这是最常见的，其背后可能的原因多种多样，例如：
        *   **空指针异常（NullPointerException）：** 代码中对一个null对象进行了操作。
        *   **数据库错误：** 比如数据库连接池满了、SQL语句有语法错误、或者主键冲突。
        *   **资源耗尽：** 比如内存溢出（OOM）、线程池满了等。
        *   **配置错误：** 比如代码依赖的某个配置文件不存在或格式错误。

*   **3. 依赖端异常（下游服务问题）：** 在微服务架构下，一个接口通常会依赖其他多个服务，任何一个下游服务出问题都可能导致当前接口异常。
    *   **下游服务超时：** 调用下游服务时，等待时间过长，触发了熔断机制。
    *   **下游服务返回非预期结果：** 下游服务虽然返回了，但返回的是错误码或者格式不正确的数据，导致当前服务无法继续处理。
    *   **下游服务不可用：** 下游服务正在发布、或者已经宕机。

*   **4. 业务逻辑异常：** 这类异常是程序逻辑上需要处理的“正常”错误，需要接口返回明确的业务错误码。
    *   **权限不足：** 用户没有权限执行该操作，应返回401或403。
    *   **资源不存在：** 比如尝试查询一个ID不存在的商品，应返回404 Not Found。
    *   **状态不匹配：** 比如尝试取消一个已经发货的订单。
    *   **业务规则冲突：** 比如用户尝试领取一张已经达到领取上限的优惠券。

在测试时，我会针对以上四种维度的异常，设计专门的测试用例，以确保我们的系统在各种意外情况下都能做出健壮、优雅的响应。

> **补充说明：**
> *   **分类归纳：** 将异常进行分类，体现了你结构化的思维能力。这种分类方法（输入、服务、依赖、业务）几乎可以涵盖所有情况，非常全面。
> *   **微服务视角：** 提到“依赖端异常”和“微服务”，说明你对现代软件架构有了解，这在面试中是一个加分项。
> *   **区分“错误”与“异常”：** 能区分开服务器内部错误（如5xx）和业务逻辑异常（如4xx），并知道它们应该返回不同的HTTP状态码，说明你对HTTP协议和RESTful API的设计原则有很好的理解。

### 6. 测试一个请求头要关注什么

**简短回答 (50-70分):**

**面试官您好，测试请求头时，我会重点关注几个关键的Header。** 首先是`Content-Type`，确保它和请求体的格式匹配，比如是`application/json`还是`application/x-www-form-urlencoded`。其次是`Authorization`或`Cookie`，用于测试接口的认证和鉴权逻辑。我还会测试`Accept`头，看服务器能否根据客户端期望的格式返回数据。最后，我会测试一些自定义的Header，比如版本号、客户端信息等。

**深度回答:**

**面试官您好，请求头（Request Header）是客户端与服务端之间传递元数据的重要载体，对它的测试是接口测试中非常关键的一环。我会从“标准Header”、“自定义Header”和“异常场景”三个方面来系统性地测试请求头。**

*   **1. 标准Header的测试：**
    *   `Content-Type`: 这是最重要的Header之一。我会测试：
        *   **正确性：** 发送JSON格式的请求体时，`Content-Type`必须是`application/json`。
        *   **不匹配：** 故意让`Content-Type`和请求体格式不匹配，比如`Content-Type`是`application/json`但请求体是`key=value`格式，看服务器是否能正确拒绝并返回4xx错误。
        *   **缺失：** 对于POST/PUT请求，不传`Content-Type`，看服务器的默认处理行为是否符合预期。
    *   `Authorization` / `Cookie`: 这两个是身份认证的关键。
        *   **有效性：** 使用有效的Token或Cookie，验证是否能成功访问。
        *   **无效/过期：** 使用一个无效的、或已过期的Token/Cookie，验证是否返回401 Unauthorized。
        *   **权限：** 使用一个低权限用户的Token去访问高权限接口，验证是否返回403 Forbidden。
        *   **缺失：** 不带任何认证头，验证是否能正确拦截。
    *   `Accept`: 告诉服务器客户端期望接收的数据类型。
        *   我会测试`Accept: application/json`，`Accept: application/xml`等，看服务器能否根据该头部返回不同格式的数据（如果支持的话）。
        *   测试一个服务器不支持的类型，看是否会返回406 Not Acceptable。
    *   `User-Agent`: 标识客户端信息。有些接口可能会根据不同的`User-Agent`（如iOS, Android, PC）返回不同的数据结构，我会模拟不同的`User-Agent`来验证这一点。

*   **2. 自定义Header的测试：**
    *   很多系统会定义自己的Header来传递特殊信息，比如：
        *   `X-Api-Version`: 用于API版本控制，我会测试不同版本号，验证接口行为是否符合对应版本的预期。
        *   `X-Request-Id`: 用于全链路追踪，我会检查这个ID是否被正确传递到下游服务和日志中。
        *   `X-Tenant-Id`: 用于多租户系统，我会用不同租户的ID进行测试，确保数据隔离性。
    *   对于这些自定义Header，我同样会测试其 **存在、缺失、格式错误** 等场景。

*   **3. 异常场景的测试：**
    *   **超长Header：** 构造一个非常大的Header值，测试服务器是否会因为超出缓冲区而崩溃，是否存在安全漏洞。
    *   **特殊字符：** 在Header值中注入特殊字符或脚本，进行基本的安全性测试。

通过以上三个方面的组合测试，我可以比较全面地保证请求头处理逻辑的健壮性和安全性。

> **补充说明：**
> *   **结构清晰：** “标准”、“自定义”、“异常”的分类方法非常清晰，能体现你的测试思路很全面。
> *   **具体Header，具体分析：** 不只是泛泛而谈，而是能列举出`Content-Type`, `Authorization`, `Accept`等具体Header，并说明针对它们各自的测试点，这会让面试官觉得你经验丰富。
> *   **安全意识：** 提到测试“超长Header”和“特殊字符”，说明你具备一定的安全测试意识，这是一个重要的加分项。

### 7. 系统测试这一块前后端结合了之后怎么测试要关注什么

**简短回答 (50-70分):**

**面试官您好，前后端结合的系统测试，我主要关注的是端到端的业务流程是否跑通。** 我会模拟真实用户的操作路径，从前端页面开始，经过一系列操作，直到数据在后端正确落库，再验证前端页面是否正确展示了结果。这个过程中，我特别关注前后端的数据交互是否准确无误，以及在不同网络环境下的用户体验。

**深度回答:**

**面试官您好，当进入前后端联调的系统测试阶段，我的角色就从一个“接口调用者”转变成了一个“真实用户”的模拟者。这个阶段的测试核心是验证整个系统作为一个整体，能否满足端到端的业务需求。** 我会重点关注以下几个方面：

*   **1. 端到端（E2E）业务流程的正确性：**
    *   我会根据用户故事（User Story），设计出覆盖主要业务场景的测试用例。比如一个电商网站，我会测试从 **“用户登录 -> 搜索商品 -> 加入购物车 -> 下单 -> 支付 -> 查看订单”** 这样一条完整的核心路径。
    *   在执行过程中，我不仅会看前端页面的反应，还会通过浏览器的开发者工具（F12）或者抓包工具（如Charles）来监控前后端的交互，确保前端传递给后端的参数是正确的，后端返回给前端的数据也是符合预期的。

*   **2. 前后端数据交互的一致性：**
    *   **数据展示：** 后端返回的数据，前端是否能正确解析并渲染到页面上。我会特别注意一些边界情况，比如数据显示不全、格式错误、或者数据为空时页面的展示状态。
    *   **数据提交：** 前端表单提交的数据，后端是否能正确接收并处理。我会验证各种合法的、非法的输入，看整个链路上的数据校验是否都生效了（前端校验、后端校验）。
    *   **状态同步：** 当后端数据发生变化时（比如订单状态被后台管理员修改），前端页面能否及时地（通过轮询或WebSocket）更新状态，保持与后端的一致性。

*   **3. 用户体验与非功能性需求：**
    *   **页面兼容性：** 我会在不同的浏览器（Chrome, Firefox等）和不同的分辨率下，测试页面的布局是否会错乱，功能是否正常。
    *   **响应速度：** 我会关注页面的加载速度和操作的响应时间。如果某个操作让页面卡顿超过3秒，我就会认为这是一个用户体验的缺陷。
    *   **弱网测试：** 我会使用工具模拟慢速网络（如3G网络），来测试系统在网络不佳的情况下的表现，比如是否有loading提示、是否会超时、超时后是否有重试机制等。

*   **4. 接口与前端的集成问题：**
    *   **跨域问题（CORS）：** 检查前端调用后端接口时是否会因为跨域策略而被浏览器阻止。
    *   **接口聚合：** 有些复杂的页面可能需要调用多个后端接口来渲染，我会关注这些接口的调用时序是否合理，是否存在可以合并的请求以优化性能。

总而言之，前后端联调的系统测试，是一个从用户的视角出发，对整个技术栈进行垂直穿越的综合性验证过程。

> **补充说明：**
> *   **端到端（E2E）视角：** 明确提出“E2E”的概念，并能描述出一条完整的业务流，说明你理解系统测试的宏观视角。
> *   **使用工具：** 提到使用“F12开发者工具”或“Charles”来辅助测试，会让你的回答显得非常真实和专业，说明你具备实际的动手排查问题的能力。
> *   **关注非功能：** 除了功能正确性，还能主动提到“兼容性”、“响应速度”、“弱网”等非功能性测试点，是体现你作为一名优秀测试工程师全面性的关键。

### 8. 项目里用到了redis为什么要用redis?

**简短回答 (50-70分):**

**面试官您好，我们在项目中引入Redis，主要是看中了它高性能的内存读写能力。** 我们用它来做缓存，将一些频繁读取且不经常变化的数据（比如商品信息）从MySQL中缓存到Redis里，这样可以大大减轻数据库的压力，提升系统的响应速度。此外，我们还用到了Redis的一些数据结构来实现分布式锁，保证高并发下数据的一致性。

**深度回答:**

**面试官您好，在我们的项目中，引入Redis是一个经过深思熟虑的架构决策，它主要为我们解决了“性能瓶颈”和“并发控制”两大类问题。**

具体来说，我们主要在以下几个场景中使用了Redis：

*   **1. 作为核心业务的缓存层 (Cache):**
    *   **背景：** 我们的项目中，像“商品详情”、“用户基本信息”这类数据，具有 **“读多写少”** 的特点。如果每次请求都直接去查询MySQL数据库，在高并发场景下，数据库会成为整个系统的性能瓶颈。
    *   **解决方案：** 我们引入Redis作为MySQL的前置缓存。当一个读请求进来时，系统会 **先去Redis里查找数据**。如果找到了（缓存命中），就直接返回，这个过程是毫秒级的内存操作，非常快。如果没找到（缓存穿透），我们才去查询MySQL，然后将从MySQL中查到的数据 **回写到Redis中**，并设置一个合理的过期时间。这样，后续的请求就能从缓存中快速获取了。
    *   **效果：** 通过这种方式，我们将热点数据的查询性能提升了几个数量级，系统的整体QPS得到了显著提高，并且有效保护了后端的MySQL数据库。

*   **2. 实现分布式锁 (Distributed Lock):**
    *   **背景：** 在一些并发场景下，比如“秒杀活动中扣减库存”，我们需要保证同一时间只有一个线程能够执行扣减操作，否则就会出现超卖的问题。在单体应用中，我们可以用Java的`synchronized`关键字来解决，但在分布式、多实例部署的微服务架构下，JVM层面的锁就失效了。
    *   **解决方案：** 我们利用了Redis的 `SETNX` (SET if Not eXists) 命令。这个命令的特性是，只有在key不存在时才能设置成功。我们可以让多个服务实例去尝试`SETNX`同一个key（比如`lock:product_id_123`），只有一个实例能成功，成功的那个实例就获得了“锁”，可以执行后续的业务逻辑。执行完毕后，再通过`DEL`命令释放锁。
    *   **效果：** 通过Redis分布式锁，我们确保了在分布式环境下高并发操作的数据一致性。

*   **3. 作为高速队列 (Queue):**
    *   **背景：** 一些非核心、耗时的操作，比如“用户下单后发送短信通知”，我们不希望它阻塞主流程。
    *   **解决方案：** 我们使用了Redis的List数据结构（`LPUSH`/`RPOP`）实现了一个简单的消息队列。下单服务在完成核心逻辑后，只需要将一个“发送短信”的任务`LPUSH`到队列中，就可以立即返回了。然后，我们有专门的后台服务去消费这个队列，异步地执行发送短信的操作。
    *   **效果：** 这种异步削峰的方式，降低了主流程的响应时间，提升了用户体验。

总结来说，Redis对我们而言，不仅仅是一个简单的key-value数据库，更是我们用来提升系统性能、保证数据一致性的一个关键中间件。

> **补充说明：**
> *   **说出具体场景：** 不要只说“用Redis做缓存”，而是要说出“为什么用缓存（读多写少）”、“怎么用的（先查缓存，再查DB，再回写）”、“用在什么业务上（商品信息）”，这样才显得真实可信。
> *   **展示知识广度：** 除了最常见的缓存，还能提到“分布式锁”、“消息队列”等进阶用法，能极大地提升面试官对你技术广度的评价。
> *   **说出关键命令：** 在讲分布式锁时，能准确地说出核心命令`SETNX`，会非常有说服力。

### 9. 如果现在要你测项目里redis的使用你关注什么

**简短回答 (50-70分):**

**面试官您好，测试Redis的使用，我会从功能、性能和高可用三个层面入手。** 功能上，我会验证缓存的读写、更新和失效策略是否正确，以及分布式锁是否能有效防止并发问题。性能上，我会关注Redis的响应时间和命中率。高可用方面，我会模拟主节点宕机，看从节点能否顺利接管，保证服务的连续性。

**深度回答:**

**面试官您好，对于像Redis这样的核心中间件的测试，我会把它当成一个独立的服务来对待，并从“功能正确性”、“性能表现”、“高可用与数据安全”以及“资源监控”四个维度进行系统性的验证。**

*   **1. 功能正确性测试：**
    *   **缓存逻辑测试：**
        *   **数据一致性：** 当数据库中的数据更新后（比如修改了商品价格），缓存中的数据是否能被正确地 **更新或淘汰**，这是最重要的测试点。我会验证我们采用的缓存更新策略（比如先更新DB再删除Cache）是否在各种情况下都有效。
        *   **缓存穿透测试：** 我会用一个数据库里肯定不存在的ID去频繁请求，看系统是否将“空结果”也缓存了，以防止请求一直打到数据库上。
        *   **缓存雪崩/击穿测试：** 我会和开发讨论，在设计上是否有机制来应对大量缓存在同一时间失效（雪崩）或一个热点Key失效（击穿）的场景，比如设置随机的过期时间、使用分布式锁来加载热点数据等。
        *   **过期策略测试：** 验证key的过期时间（TTL）是否设置合理，是否能被正确地自动删除。
    *   **分布式锁功能测试：**
        *   **互斥性：** 我会用多线程或多进程工具，模拟大量并发请求，验证同一时间是否只有一个请求能获取到锁。
        *   **防死锁：** 验证锁是否设置了过期时间。我会模拟一个拿到锁的线程崩溃的场景，看锁能否在超时后被自动释放，避免死锁。
        *   **可重入性：** 如果业务需要，验证同一个线程是否可以重复获取同一个锁。

*   **2. 性能表现测试：**
    *   **缓存命中率：** 我会监控Redis的缓存命中率（Hit Rate）。如果命中率过低，说明缓存的使用方式可能存在问题，我会和开发一起分析原因。
    *   **响应时间（RT）：** 我会压测使用了Redis的接口，观察Redis自身的响应时间，确保其在不同并发量级下都能维持在毫秒级。
    *   **连接数：** 监控Redis的客户端连接数，确保没有连接泄露的问题。

*   **3. 高可用与数据安全测试：**
    *   **主从复制测试：** 在主节点（Master）上写入数据，立即去从节点（Slave）上读取，验证数据同步的延迟是否在可接受范围内。
    *   **故障切换（Failover）测试：** 如果部署了哨兵（Sentinel）或集群（Cluster）模式，我会手动kill掉主节点，测试从节点是否能被自动提升为新的主节点，以及整个切换过程对业务的影响有多大（比如是否有请求失败）。
    *   **数据持久化测试：** 如果开启了RDB或AOF，我会测试在Redis重启后，数据是否能从磁盘文件中成功恢复。

*   **4. 资源监控：**
    *   我会关注Redis服务器的 **内存使用率**，设置告警，防止内存被用满。同时也会关注CPU和网络IO等指标。

通过以上维度的测试，我可以全面地评估我们项目中Redis使用的正确性、稳定性和性能表现。

> **补充说明：**
> *   **体系化思维：** “功能、性能、高可用、监控”的四维模型非常全面，能体现你对中间件测试的深刻理解。
> *   **专业术语：** 能准确地说出“缓存穿透、雪崩、击穿”、“主从复制”、“故障切换”、“RDB/AOF”等专业术语，并解释它们的测试方法，是面试官非常希望看到的。
> *   **风险意识：** 提到测试“死锁”、“数据一致性”等问题，说明你具备很强的风险意识，知道在复杂的分布式系统中什么地方最容易出问题。

### 10. 数据库还有很多分库分表操作主从复制怎么测试？

**简短回答 (50-70分):**

**面试官您好，对于分库分表和主从复制的测试，我主要关注数据一致性和正确性。** 对于分库分表，我会重点测试数据能否根据分片键正确地路由到对应的库和表中，以及跨库跨表的查询和聚合操作是否正确。对于主从复制，我会测试主库写入数据后，从库的数据同步延迟，并模拟主库宕机，看读请求是否能平滑地切换到从库。

**深度回答:**

**面试官您好，分库分表和主从复制是数据库架构为了应对高并发和大数据量所做的优化，对它们的测试核心是保证数据在分布式环境下的正确性和一致性。** 我会从“分库分表”和“主从复制”两个方面来分别阐述我的测试策略。

**一、 分库分表（Sharding）的测试策略：**

分库分表的测试重点在于验证 **数据路由的正确性** 和 **数据操作的完整性**。

*   **1. 数据写入与路由测试：**
    *   我会根据我们设定的分片键（Sharding Key，比如`user_id`或`order_id`），准备一系列测试数据。
    *   然后，通过业务接口执行插入操作，再直接连接后台的物理数据库，验证这些数据是否按照预期的分片规则，准确地落在了正确的库和正确的表中。例如，`user_id`为偶数的用户是否都落在了`db_0`，奇数用户是否都落在了`db_1`。
    *   我还会特别测试一些边界值的分片键，比如`user_id`为0或非常大的值。

*   **2. 数据查询测试：**
    *   **单片查询：** 测试那些带了分片键的查询（如`SELECT * FROM t_order WHERE user_id = ?`），验证它是否能被正确地路由到单个库/表，并且返回了正确的数据。
    *   **跨片查询/广播查询：** 测试那些不带分片键的查询（如`SELECT * FROM t_order WHERE status = ?`）。这种查询通常会路由到所有的库/表中执行。我会重点验证：
        *   查询结果是否是所有分片结果的正确合并。
        *   分页、排序等操作在跨片查询下是否还能正常工作。
        *   这种查询的性能是否在可接受范围内，因为它会对数据库造成较大压力。

*   **3. 数据修改与删除测试：**
    *   与查询类似，我会验证带分片键和不带分片键的`UPDATE`和`DELETE`操作是否都能正确执行。

*   **4. 扩容与数据迁移测试：**
    *   如果项目有数据库扩容计划，我会参与测试数据迁移的过程。验证迁移工具是否能正确地将旧库的数据搬迁到新的分片中，以及在迁移过程中，业务的读写操作是否会受影响。

**二、 主从复制（Master-Slave Replication）的测试策略：**

主从复制的测试重点在于验证 **数据同步的可靠性** 和 **故障切换的可用性**。

*   **1. 数据同步测试：**
    *   **同步延迟（Replication Lag）：** 我会写一个脚本，持续地在主库（Master）上进行写操作，同时在从库（Slave）上进行读操作，计算数据从主库写入到从库可读的平均时间差。这个延迟是一个非常关键的性能指标。
    *   **数据一致性校验：** 我会定期（比如每晚）运行一个数据校验脚本，对比主从库的数据，确保数据是最终一致的。

*   **2. 读写分离测试：**
    *   验证系统是否按照预期，将所有的写操作（INSERT, UPDATE, DELETE）都路由到了主库，而将大部分的读操作（SELECT）都路由到了从库。

*   **3. 故障切换（Failover）测试：**
    *   这是最重要的测试点。我会通过模拟各种故障场景，来检验系统的高可用性：
        *   **模拟主库宕机：** 我会手动关闭主库的数据库进程，然后观察：
            *   监控系统是否能及时发现主库不可用。
            *   是否有自动或手动的机制，能将一个从库提升为新的主库。
            *   在切换过程中，业务的写操作是被阻塞还是报错，对用户的影响有多大。
            *   当旧的主库恢复后，它是否能正确地降级为新主库的从库。
        *   **模拟主从网络中断：** 我会使用防火墙（iptables）断开主从之间的网络连接，测试数据同步中断和恢复的场景。

通过以上测试，我可以确保我们的数据库架构在分库分表和主从复制的复杂场景下，依然能够稳定、可靠地工作。

> **补充说明：**
> *   **深入底层：** 这个问题非常考验测试人员的技术深度。不能只停留在“点业务”的层面，而是要能深入到底层架构，理解分库分表、主从复制的原理，并设计出针对性的测试方案。
> *   **区分测试点：** 能清晰地把“分库分表”和“主从复制”的测试点分开阐述，并抓住各自的核心（前者是路由，后者是同步和切换），说明你的思路非常清晰。
> *   **破坏性测试：** 在高可用测试中，能想到去“模拟宕机”、“模拟网络中断”这种破坏性的测试手段，是高级测试工程师必备的素质，也是体现你能力的重要机会。

### 11. 算法1：三数之和

**简短回答 (50-70分):**

**面试官您好，这道题是“两数之和”的升级版，我的思路是“排序 + 双指针”。** 首先，我会对整个数组进行排序。然后，我遍历这个数组，对于每个元素`nums[i]`，我将其视为三元组中的第一个数。接着，我在`i`后面的区间里，使用“双指针”法，一个指针`left`指向`i+1`，另一个指针`right`指向数组末尾。根据三个数的和与0的比较结果，来移动`left`或`right`指针，直到找到所有满足条件的三元组。同时，我会注意处理重复解的问题。

**深度回答:**

**面试官您好，对于“三数之和”等于0这个问题，一个高效且经典的解法是采用“排序 + 双指针”的策略。这个方法可以将暴力解法O(n³)的时间复杂度优化到O(n²)。**

我的解题步骤如下：

**1. 预处理与特例判断：**
*   首先，我会判断数组的长度是否小于3，如果小于3，则不可能组成三元组，直接返回空列表。
*   然后，对整个数组进行 **升序排序**。排序是这个算法能够使用双指针的前提，它有两个关键作用：
    1.  方便我们通过移动指针来调整三数之和的大小。
    2.  方便我们进行后续的去重操作。

**2. 主循环（固定第一个数）：**
*   我使用一个for循环来遍历排序后的数组，循环变量为`i`，`nums[i]`就是我们尝试固定的第一个数。
*   **剪枝优化：** 如果`nums[i]`已经大于0，因为数组是排好序的，所以后面的数肯定也都大于0，三数之和不可能等于0。因此，可以直接跳出循环。
*   **去重处理1：** 如果当前的`nums[i]`和上一个`nums[i-1]`相等，说明这个数我们已经作为第一个数考虑过了，为了避免产生重复的三元组，直接`continue`跳过本次循环。

**3. 双指针查找（寻找另外两个数）：**
*   在确定了第一个数`nums[i]`之后，问题就转化为了在`i`后面的子数组中寻找“两数之和”等于`-nums[i]`的问题。
*   我定义两个指针：左指针`left`，初始指向`i + 1`；右指针`right`，初始指向数组的末尾`len(nums) - 1`。
*   我启动一个`while (left < right)`循环，在循环中计算三个数的和`sum = nums[i] + nums[left] + nums[right]`。
*   根据`sum`和0的比较结果，来移动指针：
    *   如果`sum < 0`，说明和太小了，需要增大。因为数组是排好序的，所以我们向右移动左指针`left++`。
    *   如果`sum > 0`，说明和太大了，需要减小。我们向左移动右指针`right--`。
    *   如果`sum == 0`，恭喜，我们找到了一个满足条件的三元组！我将`[nums[i], nums[left], nums[right]]`存入结果列表中。

**4. 找到答案后的去重处理：**
*   当`sum == 0`找到一个解之后，不能立即停止。因为`left`和`right`之间可能还存在其他的解。
*   但是，为了避免`[ -1, 0, 1]`和`[ -1, 0, 1]`这样的重复解，我们需要进行 **去重处理2**：
    *   我会用一个while循环，将`left`指针移动到下一个不等于当前`nums[left]`的位置。
    *   同样，用一个while循环，将`right`指针移动到下一个不等于当前`nums[right]`的位置。
    *   完成去重后，再将`left`和`right`各自向中间移动一位，继续寻找新的可能解。

**5. 返回结果：**
*   主循环结束后，返回存储所有不重复三元组的结果列表。

这个算法的整体时间复杂度是O(n²)，其中排序是O(n log n)，双指针的查找是O(n²)。空间复杂度是O(1)（不考虑存储结果的空间）。

> **补充说明：**
> *   **思路转换：** 能清晰地讲出“将三数之和问题转化为两数之和问题”的思路转换，是解决这类问题的关键。
> *   **双重去重：** 这个算法的难点在于去重。能讲清楚在两个不同位置（固定第一个数时去重、找到解后移动双指针时去重）的去重逻辑，说明你对算法的细节有很好的把握。
> *   **剪枝：** 提到`nums[i] > 0`就跳出的剪枝优化，能体现你对算法效率的追求。

### 12. 算法2：1分2分5分的硬币组成1块钱且总数要求为50枚各币种至少使用1枚问有几种组合方式？

**简短回答 (50-70分):**

**面试官您好，这是一个三元一次方程组求解的问题。** 我们可以设1分、2分、5分的硬币数量分别为x, y, z。根据题意，我们可以列出两个方程：`x + y + z = 50` (总数量为50枚) 和 `x + 2y + 5z = 100` (总金额为100分)。这是一个不定方程，我们可以通过消元和设定变量的取值范围来求解。我会用一个循环来遍历其中一个变量（比如z），然后根据z的值推算出x和y的值，再判断x和y是否满足大于等于1的整数条件。

**深度回答:**

**面试官您好，这个问题本质上是一个求解三元一次不定方程组的整数解的问题。我的解题思路是通过“代数消元”将问题简化，然后通过“循环遍历”来找出所有满足条件的解。**

**1. 建立数学模型：**

首先，我们用代数的方式来描述这个问题。设1分、2分、5分的硬币数量分别为 `x`, `y`, `z`。根据题目给出的两个约束条件，我们可以列出以下两个方程：

*   方程一（数量约束）：`x + y + z = 50`
*   方程二（金额约束）：`x + 2y + 5z = 100`

同时，题目还隐含了一个条件：`x, y, z`都必须是大于等于1的整数。

**2. 代数消元，简化问题：**

我们有两个方程，三个未知数，直接解是解不出来的。但我们可以通过消元，减少未知数的数量。

*   我选择消去 `x`。由方程一可得：`x = 50 - y - z`。
*   将这个表达式代入方程二，得到：
    `(50 - y - z) + 2y + 5z = 100`
*   整理这个方程，可以得到 `y` 和 `z` 的关系：
    `y + 4z = 50`
    即 `y = 50 - 4z`

现在，问题被简化了：我们只需要找到满足 `y = 50 - 4z` 的正整数解 `(y, z)`，然后就能反推出 `x` 的值，再判断 `x` 是否也为正整数即可。

**3. 循环遍历，求解答案：**

接下来，我可以通过循环来寻找 `z` 的所有可能取值。

*   **确定 `z` 的取值范围：**
    *   因为 `x, y, z` 都至少为1，所以 `z >= 1`。
    *   从 `y = 50 - 4z` 来看，为了保证 `y >= 1`，那么 `50 - 4z >= 1`，可以解得 `4z <= 49`，所以 `z <= 12.25`。
    *   同时，我们还需要保证 `x >= 1`。将 `y = 50 - 4z` 代入 `x = 50 - y - z`，得到 `x = 50 - (50 - 4z) - z = 3z`。为了保证 `x >= 1`，那么 `3z >= 1`，即 `z >= 1/3`。
    *   综合以上条件，`z` 的取值范围是 `[1, 12]` 之间的整数。

*   **编写循环：**
    *   我可以写一个for循环，让 `z` 从1遍历到12。
    *   在循环的每一步中，根据当前的 `z` 值，计算出 `y = 50 - 4z` 和 `x = 3z`。
    *   由于我们在推导 `z` 的范围时已经保证了 `x` 和 `y` 都是正整数，所以只要 `z` 在 `[1, 12]` 这个范围内，每一组 `(x, y, z)` 都是一个有效的解。

**4. 得出结论：**

*   `z` 可以从1取到12，共12个整数值。每一个 `z` 的值都对应唯一的一组 `(x, y)`，从而构成一个有效的硬币组合。
*   因此，总共有 **12种** 组合方式。

例如：
*   当 `z=1` 时，`x=3`, `y=46`。组合为(3, 46, 1)，满足条件。
*   当 `z=12` 时，`x=36`, `y=2`。组合为(36, 2, 12)，满足条件。

这个解法逻辑清晰，且计算量很小，能够快速准确地得到答案。

> **补充说明：**
> *   **数学建模能力：** 这个问题考察的不是复杂的编程技巧，而是将实际问题抽象成数学模型的能力。能快速列出方程组是第一步。
> *   **逻辑推理：** 解题的关键在于通过消元和推导，找出变量的取值范围。能清晰地推导出`z`的范围是`[1, 12]`，说明你的逻辑推理能力很强。
> *   **笨办法 vs 巧办法：** 面经中提到的“笨思路”是两层for循环，而这个解法是一层for循环。在面试时，可以先提一下暴力解法，然后马上提出这个更优的、基于数学推导的解法，更能体现你的思考深度。