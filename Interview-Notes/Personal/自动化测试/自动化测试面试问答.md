# [自动化测试面试问答（一）](https://www.nowcoder.com/discuss/770046385369387008?sourceSSR=users)

### 1、请描述一下自动化测试流程?

1）需求分析：明确自动化测试范围和目标  

2）工具选型：选择框架（Pytest/Unittest）、工具（Selenium/Requests）  

3）环境搭建：配置测试环境、依赖库  

4）用例设计：编写可自动化的测试用例  

5）脚本开发：用PO模式编写可维护脚本  

6）测试执行：CI集成（Jenkins/GitLab CI）  

7）结果分析：日志/报告（Allure）定位问题  

8）维护更新：随需求迭代更新脚本

### 2、你是如何做接口自动化测试的?

[复制代码](自动化测试面试问答.md#)

```
# 示例：使用Requests+Pytest``import` `requests``import` `pytest` `def test_login():``  ``url = ``"https://api.example.com/login"``  ``data = {``"user"``: ``"admin"``, ``"pass"``: ``"123456"``}``  ``res = requests.post(url, json=data)``  ``assert` `res.status_code == ``200``  ``assert` `res.json()[``"token"``] is not None
```

### 3、简单介绍一下Requets库?

Python HTTP库：

发送HTTP请求（GET/POST/PUT/DELETE）

处理响应数据（JSON/XML/text）

会话管理（Session维持Cookie）

超时设置/SSL验证安装：pip install requests

### 4、具体说一说Unittest测试框架?

[复制代码](自动化测试面试问答.md#)

```
import` `unittest` `class` `TestMath(unittest.TestCase):``  ``def setUp(self): # 前置操作``    ``self.calc = Calculator()``  ` `  ``def test_add(self): # 测试方法需以test_开头``    ``self.assertEqual(self.calc.add(``2``,``3``), ``5``)``  ` `  ``def tearDown(self): # 清理资源``    ``del self.calc` `if` `__name__ == ``"__main__"``:``  ``unittest.main()
```

### 5、具体说一说Pytest测试框架?

​        1）无需继承类：函数即用例  

​        2）Fixture机制：灵活管理测试资源  

​        3）参数化：@pytest.mark.parametrize简化数据驱动  

​        4）插件丰富：Allure报告、并发执行(pytest-xdist)  

​        5）断言直观：直接使用‘assert’  

### 6、Unittest 与 Pytest 测试框架的区别?

​    Unittest vs Pytest

| **用例写法** | 需继承TestCase   | 普通函数           |
| ------------ | ---------------- | ------------------ |
| **前置后置** | setUp/tearDown   | Fixture装饰器      |
| **参数化**   | 需用subprocess   | 内置parametrize    |
| **报告**     | HTMLTestRunner   | Allure（更美观）   |
| **社区生态** | 官方库，功能稳定 | 插件丰富，扩展性强 |

### 7、接口自动化如何做接口关联测试?

​        1）Token传递：登录接口获取token → 存入全局变量 → 后续请求携带  

​        2）数据传递：创建订单返回order_id → 作为参数传给查询接口  

​        3）实现方式：Pytest的fixture共享数据，封装全局的Session对象管理状态

### **8、做Web自动化如何处理验证码?**

方法一：万能验证码，让测试环境固定验证码

方法二：屏蔽验证码，让开发临时关闭验证功能

方法三：OCR识别，使用Tesseract库识别图片提取验证码

方法四：借助第三方平台，付费API(打码平台)

方法五：Cookie绕过，手动登录后服用Cookie

### 9、抓取不到元素可能是什么原因?

原因一：定位问题，findelement的路径有问题

原因二：时机问题，没有在等待的时间内等到元素（未等待元素加载）

原因三：结构问题，元素在shadow dom内，或者页面元素包含在iframe内未切换

原因四：状态问题，元素被遮挡，页面未完全渲染（Ajax加载）

### 10、具体聊一聊自动化测试的作用?

1）提升效率：回归测试速度提升10倍+ 2）保证质量：高频执行避免人为遗漏 3） 降低成本：减少重复人力投入 4）持续反馈：CI/CD快速发现缺陷 5） 覆盖困难场景：压力测试/兼容性测试

不适合UI频繁变更的功能，需平衡自动化投入与收益

### 11、自动化测试调试思路

​        调试一些思路:

​        第一步：看log，看看哪里出错了,

​        第二步：看截图，看视频，找到是哪里出错

​        第三步：手工重复步骤，看看用手工操作是否会在相同的地方出错

​        第四步：检查xpath的路径，在当前页面是否可以正常找到

​        第五步：用js的高亮元素代码，看看程序是否可以正确找到

​        第六步：换一种xpath的写法，或者点击原来元素的父元素,或者子元素

​        第七步：添加等待时间，是否元素没有出现就去操作了，出错后，是需要进行调试的



作者：玖拾肆
链接：https://www.nowcoder.com/discuss/770046385369387008?sourceSSR=users
来源：牛客网

# [自动化测试面试问答（二）](https://www.nowcoder.com/discuss/770684944644329472?sourceSSR=users)

### 1、Java 执行selenium和Python 执行selenium有什么区别？

​    核心功能相同：二者都使用 Selenium WebDriver 的API，能实现完全相同的浏览器自动化操作（打开网页、点击、输入等）。

​    主要区别在于编程语言本身及生态：

| 特性                | Java + Selenium                                              | Python + Selenium                                            |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语言特性            | 强类型、静态语言，代码严谨但相对冗长                         | 弱类型、动态语言，语法简洁，编写速度快                       |
| 代码示例 (打开百度) | WebDriver driver = new ChromeDriver();driver.get("https://www.baidu.com"); | driver = webdriver.Chrome()driver.get("https://www.baidu.com") |
| 学习曲线            | 需理解面向对象、类型系统，入门门槛略高                       | 语法接近自然语言，新手友好，上手更快                         |
| 开发效率            | 代码量通常更大，编译步骤稍慢                                 | 代码简洁，无需编译，快速原型开发首选                         |
| 生态与库支持        | 成熟企业级生态（JUnit/TestNG, Maven/Gradle）                 | 丰富的数据科学库（Pandas, NumPy），适合爬虫                  |
| 应用场景            | 大型企业级测试框架，需要强类型保障的长期项目                 | 快速脚本、爬虫、中小型测试项目，AI结合场景                   |
| 社区与资源          | 历史悠久，企业应用广泛，文档丰富                             | 增长迅猛，尤其在测试自动化和爬虫领域                         |
| 执行速度            | JVM优化后通常更快                                            | 略慢于Java，但日常操作差异不明显                             |

**如何选择？**

- 选 Java：团队已有Java基础或企业级测试框架（如TestNG）。项目需要强类型检查和长期维护。
- 选 Python：快速实现需求（写脚本、爬虫、小型测试）。团队熟悉Python或需要结合数据分析/机器学习。新手入门更轻松。

✅ **总结**：功能无差距，差异在语言。**Python适合敏捷开发和初学者，Java适合大型企业级项目**。根据团队技术栈和项目需求选择即可。

### 2、隐性等待和显性等待的区别？

| 特性       | 隐性等待 (Implicit Wait)           | 显性等待 (Explicit Wait)               |
| ---------- | ---------------------------------- | -------------------------------------- |
| 作用范围   | 全局（影响所有 find_element 操作） | 局部（仅针对当前等待语句）             |
| 等待条件   | 仅检查元素存在                     | 支持多种条件（可见、可点击、文本等）   |
| 灵活性     | 低                                 | 高（可定制复杂条件）                   |
| 效率       | 可能产生冗余等待                   | 高效（条件满足即退出）                 |
| 适用场景   | 简单页面，元素加载稳定             | 动态页面（AJAX/SPA），需条件判断的操作 |
| 代码复杂度 | 简单（一行配置）                   | 较高（需定义条件和等待对象）           |

### 3、如果页面上的元素用隐性等待和显性等待都没等到元素加载出来，请问要怎么办？

​      思路：

- 优先手动验证：确认元素在HTML中真实存在
- 定位器优化：使用更健壮的XPath/CSS，处理iframe/Shadow DOM
- 精准等待条件：确保等待的是可交互状态（非仅存在）
- 控制页面加载：设置 page_load_strategy 和超时时间
- 环境兜底：最大化窗口、版本匹配、添加重试
- 终极方案：用JavaScript直接探测元素状态



​        1）验证元素是否存在（基础检查）

- 手动验证：在浏览器开发者工具（F12）中手动执行定位表达式，确认元素是否存在。
- 检查时机：在等待后添加 driver.page_source 输出当前HTML源码，检查元素是否被加载（可能被动态移除）。

​        2）定位策略失效的排查（核心原因）

- 定位器问题

| 问题类型         | 解决方案                                                     |
| ---------------- | ------------------------------------------------------------ |
| 过时定位器       | 检查元素属性（ID/Class）是否随页面刷新/重渲染变化（常见于SPA应用） |
| 动态生成元素     | 使用更稳定的定位方式：XPath结合文本、父节点关系，或CSS属性选择器 |
| 元素在iframe中   | 切换至iframe：driver.switch_to.frame("frame_id/name/index")后再定位 |
| 元素在Shadow DOM | 使用driver.execute_script()穿透Shadow Root（需JS脚本辅助）   |

- 等待条件不匹配

[复制代码](自动化测试面试问答.md#)

```
# 显性等待的常见误用：等待``"存在"` `≠ 等待``"可交互"``WebDriverWait(driver, ``10``).until(``  ``EC.presence_of_element_located((By.ID, ``"btn"``)) # 元素存在但可能被遮挡/不可点击``)``# 应改用可交互条件：``EC.element_to_be_clickable((By.ID, ``"btn"``)) # 确保元素可操作
```

​    3) 页面状态异常（进阶排查）

| 场景           | 解决方案                                                     |
| -------------- | ------------------------------------------------------------ |
| 页面未完全加载 | 设置页面加载策略：options.page_load_strategy = 'eager'（放弃加载图片等资源） |
| AJAX/JS未完成  | 自定义等待条件：检查JS变量或特定元素状态                     |
| 弹窗遮挡元素   | 关闭弹窗：driver.switch_to.alert.dismiss()或执行JS移除遮挡层 |
| 新窗口/标签页  | 切换窗口句柄：driver.switch_to.window(driver.window_handles[1]) |

​    4) 自定义等待条件（终极手段）

​    当内置条件不满足时，用JavaScript轮询目标状态：

[复制代码](自动化测试面试问答.md#)

```
def wait_for_element_state(driver, selector, state=``"visible"``, timeout=``10``):``  ``script = ``""``"``    ``const` `el = document.querySelector(arguments[``0``]);``    ``if` `(arguments[``1``] === ``'visible'``) ``      ``return` `el && getComputedStyle(el).display !== ``'none'``;``    ``// 可扩展其他状态：enabled, hasText...``  ``""``"``  ``return` `WebDriverWait(driver, timeout).until(``    ``lambda d: d.execute_script(script, selector, state)``  ``)` `# 使用示例``wait_for_element_state(driver, ``"#dynamicElement"``, ``"visible"``)
```

5) 环境与执行问题

| 问题                 | 解决方案                                           |
| -------------------- | -------------------------------------------------- |
| 浏览器窗口太小       | 最大化窗口：driver.maximize_window()               |
| 资源加载超时         | 增加页面加载超时：driver.set_page_load_timeout(60) |
| 浏览器驱动版本不匹配 | 使用webdriver-manager自动匹配驱动                  |
| 偶发性失败           | 添加重试机制（如tenacity库）                       |

### 4、xpath查找元素时间过长，要怎么优化，提高效率？

思路：

- 能否用CSS选择器替代？ (优先选择)
- 是否限定搜索范围？ (父元素上下文)
- 是否避免使用//和contains()？
- 是否指定了标签类型？ (避免*通配符)
- 是否禁用不必要的全局等待？
- 是否分阶段处理动态内容？
- 是否使用浏览器原生XPath？



1）优化 XPath 表达式

- 避免低效语法，使用精准定位
- 低效：模糊匹配
- 高效：精确匹配 + 属性限定

| 低效写法                       | 高效替代方案              | 效率提升原理             |
| ------------------------------ | ------------------------- | ------------------------ |
| //div//span                    | //div/span                | 减少中间节点扫描         |
| //*[@class='btn']              | //button[@class='btn']    | 限定标签类型减少搜索范围 |
| //div[contains(@class,'icon')] | //div[@class='user-icon'] | 避免函数计算             |

2）缩小搜索范围

- 从父节点开始查找

[复制代码](自动化测试面试问答.md#)

```
# 先快速定位父元素（用ID/CSS）``parent = driver.find_element(By.ID, ``"form-container"``)``# 再在父元素内用XPath``child = parent.find_element(By.XPATH, ``".//input[@name='email']"``) # 注意开头的点(.)
```

- 利用最近定位点

[复制代码](自动化测试面试问答.md#)

```
# 已定位元素作为上下文``known_element = driver.find_element(By.CSS_SELECTOR, ``"#sidebar"``)``target = known_element.find_element(By.XPATH, ``"following-sibling::div[1]"``)
```

3）改用 CSS 选择器

CSS 选择器通常比 XPath 快 5-10 倍（浏览器原生优化）

[复制代码](自动化测试面试问答.md#)

```
# XPath 低效定位``//div[@class='container']/ul/li[3]/a` `# CSS 高效替代``driver.find_element(By.CSS_SELECTOR, ``"div.container > ul > li:nth-child(3) > a"``)
```

 4）优化等待策略

- 精准显性等待

[复制代码](自动化测试面试问答.md#)

```
# 只等待必要的最小元素出现``WebDriverWait(driver, ``10``).until(``  ``EC.presence_of_element_located((By.ID, ``"essential_element"``)))` `# 后续再查找复杂XPath``element = driver.find_element(By.XPATH, ``"//div[...]"``)
```

- 禁用隐性等待

[复制代码](自动化测试面试问答.md#)

```
# 复杂查找前关闭全局等待``driver.implicitly_wait(``0``) # 临时禁用``try``:``  ``element = driver.find_element(By.XPATH, complex_xpath)``finally``:``  ``driver.implicitly_wait(``10``) # 恢复
```

5）处理动态内容策略

- 分阶段定位

[复制代码](自动化测试面试问答.md#)

```
# 第一阶段：等待容器加载``container = WebDriverWait(driver, ``10``).until(``  ``EC.presence_of_element_located((By.ID, ``"dynamic-container"``))``)` `# 第二阶段：在容器内查找``items = container.find_elements(By.XPATH, ``".//li[contains(@class, 'item')]"``)
```

-  直接 DOM 访问

[复制代码](自动化测试面试问答.md#)

```
# 通过JS直接获取元素（比XPath快``3``-``5``倍）``script = ``"return document.querySelector('div.container > ul > li:nth-child(2)');"``element = driver.execute_script(script)
```

​    6）XPath 引擎优化

- 使用浏览器原生 XPath

[复制代码](自动化测试面试问答.md#)

```
# 启用浏览器原生XPath评估（比Selenium实现更快）``capabilities = {``  ``"goog:chromeOptions"``: {``    ``"args"``: [``"--disable-blink-features=AutomationControlled"``]``  ``}``}``driver = webdriver.Chrome(desired_capabilities=capabilities)
```

- 预编译 XPath

[复制代码](自动化测试面试问答.md#)

```
# 重复使用的XPath预编译``from selenium.webdriver.common.by ``import` `By` `search_xpath = (By.XPATH, ``"//div[@class='results']/span"``)` `# 多次使用``element1 = driver.find_element(*search_xpath)``element2 = driver.find_element(*search_xpath)
```

作者：玖拾肆
链接：https://www.nowcoder.com/discuss/770684944644329472?sourceSSR=users
来源：牛客网

# [自动化测试面试问答（三）](https://www.nowcoder.com/discuss/775002965932335104?sourceSSR=search)

#### 1、**描述一下自动化测试流程？**

- 编写自动化测试计划
- 设计自动化测试用例
- 编写自动化测试框架和脚本
- 调试并维护脚本
- 无人值守测试
- 后期脚本维护（添加用例、开发更新版本）

#### **2、自动化测试的使用场景？**

- 需求稳定，不会频繁变更。
- 研发和测试周期长，需要频繁执行回归测试。
- 需要在多种平台上重复运行相同测试的场景。
- 某些测试项目，通过手工测试无法实现，或者手工成本太高。
- 被测软件的开发较为规范，能够保证系统的可测试行

#### **3、自动化测试发现BUG多吗？**

​        不多，因为之前项目组是把已经测试通过的基本功能再进行自动化脚本编写和在后续版本执行自动化测试，它主要是保证已经测试通过的功能在新版本更新后没有问题。（UI自动化的目的不是为了发现多少Bug，主要是为了减轻重复的基础操作和线上监控的作用）

#### **4、自动化测试有误报过bug吗？产生误报怎么办？**

误报过，有时候自动化测试报告中显示发现了bug,实际去通过手工测试去确认又不存在该bug。

误报原因一般是：

- 元素定位不稳定，需要尽量提高脚本的稳定性；
- 开发更新了页面但是测试没有及时更新维护

#### **5、自动化测试过程中，你遇到了哪些问题，是如何解决的?**

根据项目实际经验回答，如：

- 频繁地变更页面，经常要修改页面对象类里面的代码
- 自动化测试偶尔出现过误报
- 自动化测试结果出现覆盖的情况：Jenkins根据时间建立文件夹
- 自动化测试代码维护比较麻烦

#### **6、在执行脚本过程，如何实现当前元素高亮显示？**

- 主要是用selenium driver.execute_script()方法，来修改js的元素
- 利用javaScript去修改当前元素的边框样式来到达高亮显示的效果

#### **7、在日历这种web 表单你是如何处理的?**

- 首先要分析当前网页使用日历插件的前端代码，看看能不能通过元素定位，点击日期实现，如果不能，可能需要借助javascript。
- 还有些日历控件一个文本输入框，可以直接sendKeys()方法来实现传入一个时间的数据。

#### **8、举例一下说明一下你遇到过哪些异常？**

- NoSuchElementException：没有该元素异常
- TimeoutException ：超时异常
- ElementNotVisibleException ：元素不可见异常
- NoSuchAttributeException ：没有这样属性异常
- NoSuchFrameException ：没有该frame异常

#### **9、关闭浏览器中quit和close的区别**

- 简单来说，两个都可以实现退出浏览器session功能，close是关闭你当前聚焦的tab页面，而quit是关闭全部浏览器tab页面，并退出浏览器session。
- quit一般用在结束测试之前的操作，close用在执行用例过程中关闭某一个页面的操作

#### **10、如何实现文件上传？**

- 定位元素后，直接使用send_keys()方法设置就行，参数为需要上传的文件的路径。
- 借助第三方工具去操作windows弹窗
- 利用sikuli，win32去操作windows弹窗

#### **11、自动化中有哪三类等待？他们有什么特点？**

- 线程等待（强制等待）如time.sleep(2)：线程强制休眠2秒钟，2秒过后，再执行后续的代码。建议少用。
- imlicitlyWait（隐式等待）会在指定的时间范围内不断的查找元素，直到找到元素或超时，特点是必须等待整个页面加载完成。
- WebDriverWait（显式等待）通常是我们自定义的一个函数代码，这段代码用来等待某个元素加载完成，再继续执行后续的代码

#### **12、你觉得自动化测试最大的缺陷是什么？**

- 不稳定
- 可靠性
- 不易维护
- 成本与收益

#### **13、如何处理多窗口？**

多窗口之间跳转处理，我们在项目中也经常遇到。就是，当你点击一个链接，这个链接会在一个新的tab打开，然后你接下来要在新tab打开的页面查找元素，

- 我们在点击链接前使用driver.current_window_handle获得当前窗口句柄。
- 再点击链接。点击后通过driver.window_handles获得所有窗口的句柄，  然后再循环找到新窗口的句柄，然后再通过driver.switch_to.window()方法跳转到新的窗口。

#### **14、Selenium 中如何保证操作元素的成功率？也就是说如何保证我点击的元素一 定是可以点击的？**

- 添加元素智能等待时间 driver.implicitly_wait(30)
- 添加强制等待时间 time.sleep()
- try 方式进行id,name,clas,x path, css selector不同方式进行定位，如 果第一种失败可以自动尝试第二种

#### **15、在selenium自动化测试中，你一般完成什么类型的测试？自动化覆盖率？**

根据实际项目经验回答，

- 主要是冒烟测试和回归测试。回归测试主要写一些功能稳定的场景，通过自动化手段去实现，节约测试时间。
- 因为自动化测试用例也是在不断的更新和迭代，没有刻意去统计，大概在30%-40%左右

#### **16、在Selenium中如何实现截图，如何实现用例执行失败才截图？**

在Selenium中提供了一个get_screenshot_as_file()的方法来截图的，一般结合try/except捕获异常时使用，进行错误截图

官网的最新方法：driver.save_screenshot(’./image.png’)

作者：玖拾肆
链接：https://www.nowcoder.com/discuss/775002965932335104?sourceSSR=search
来源：牛客网

# [自动化测试面试问答（四）](https://www.nowcoder.com/discuss/778615825879097344?sourceSSR=search)

#### 1、自动化测试中，Selenium起什么作用?与其他语言有什么区别？

​        **Selenium** 是一个核心工具，主要用于**Web应用程序的自动化测试，**显著提高测试的效率。它的作用可以概括为：**模拟真实用户操作浏览器**，自动执行测试用例，如填写表单、点击按钮等，验证Web应用的功能、兼容性和稳定性。与手动测试相比，自动化测试能更快速地完成大量重复性的测试，节约时间与资源，同时降低了人工失误的可能性。

可执行的测试：**自动化Web UI测试，跨浏览器测试，自动化回归测试，数据驱动测试**

#### 2、**Selenium的优势与局限性**

| **优势**         | 开源免费                                                    | 无需付费，社区支持强大。                         |
| ---------------- | ----------------------------------------------------------- | ------------------------------------------------ |
| 多语言支持       | 支持Python、Java、C#、JavaScript等主流语言。                |                                                  |
| 真实浏览器测试   | 直接操作浏览器，更贴近用户实际场景（区别于无头浏览器）。    |                                                  |
| 强大的元素定位   | 支持ID、XPath、CSS Selector等多种定位方式。                 |                                                  |
| 集成CI/CD        | 可与Jenkins、GitHub Actions等工具集成，实现持续测试。       |                                                  |
| **局限性**       | 无法测试非Web应用                                           | 需结合Appium（移动端）、WinAppDriver（桌面端）。 |
| 动态元素处理复杂 | 使用显式等待（WebDriverWait）解决元素加载延迟问题。         |                                                  |
| 无图形验证码处理 | 需手动绕过或使用第三方服务（如OCR识别）。                   |                                                  |
| 执行速度较慢     | 结合Selenium Grid并行测试，或使用无头模式（Headless）加速。 |                                                  |

#### 3、Selenium与其他工具相比？有什么优势？

​    Selenium 的**跨浏览器兼容性**、**多语言支持**和**成熟的生态**，使其在复杂企业级项目中仍是不可替代的工具。尽管新工具（如 Playwright）在速度和易用性上有优势，但 Selenium 的灵活性和稳定性依然是长期维护型项目的首选。

#### 4、自动化测试Web端页面，怎么去做性能测试？

​        Web性能测试核心指标：**页面加载时间，****接口响应时间，并发用户支持，资源占用，错误率**

| 测试类型   | 目的                           | 实施方法                           |
| ---------- | ------------------------------ | ---------------------------------- |
| 基准测试   | 确定单用户正常性能             | 用户循环执行核心流程               |
| 负载测试   | 验证系统在目标并发下的表现     | 逐步增加并发至业务峰值（如500TPS） |
| 压力测试   | 探测系统崩溃临界点             | 持续增加负载直到错误率＞5%         |
| 稳定性测试 | 检查内存泄漏和长时间运行可靠性 | 7*24小时持续运行                   |

#### 5、在自动化测试过程中，如何进一步提高用户体验？

在自动化测试过程中提升用户体验（User Experience, UX），需要从测试策略、工具优化、结果反馈等多个维度进行系统性改进。

- 从测试设计阶段提升用户体验
- 用户旅程覆盖自动化测试脚本应覆盖典型用户路径
- 响应速度：通过performance.timing记录关键节点时间。
- 视觉一致性：使用视觉回归工具（如Applitools）检测UI偏移。
- 无障碍访问：通过axe-core自动化检查WCAG合规性。
-    优化测试执行体验
- 智能等待机制：避免固定SLEEP，采用动态等待策略
- 失败场景人性化处理:自动截图+日志记录/失败自动重试
- 跨设备/浏览器覆盖
- 使用Selenium Grid或BrowserStack自动测试不同设备
- 持续改进闭环
- 用户反馈整合：将生产环境中的用户报错（如Sentry日志）自动转化为测试用例。
- A/B测试验证：通过自动化脚本验证不同UI设计的转化率差异。
- 性能优化验证：在CI流水线中自动验证缓存策略、CDN生效情况。

#### 6、Selenium怎么与浏览器交互？

Selenium 与浏览器的交互是通过 **浏览器驱动（WebDriver）** 实现的，它基于 **W3C WebDriver 协议**，通过 HTTP 请求与浏览器通信，模拟用户操作。**其核心流程为：****测试脚本 → WebDriver驱动 → 浏览器实例 → 返回结果**

| 组件                    | 作用                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Selenium Client Library | 提供编程语言接口（如Python的selenium包），将代码转换为WebDriver协议命令。 |
| Browser Driver          | 浏览器专属驱动（如ChromeDriver、GeckoDriver），接收指令并控制真实浏览器。 |
| 浏览器实例              | 实际执行操作的浏览器（Chrome/Firefox等）。                   |

![img](./assets/D2B5CA33BD970F64A6301FA75AE2EB22.png)

#### 7、Selenium交互的浏览器有什么不同？

|                          | 浏览器                                                  | Chrome                                                       | Firefox                                                 | Edge                                         | Safari                         | Internet Explorer                      | Opera       |
| ------------------------ | ------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- | -------------------------------------------- | ------------------------------ | -------------------------------------- | ----------- |
| 浏览器驱动与协议支持     | 驱动名称                                                | ChromeDriver                                                 | GeckoDriver                                             | MSEdgeDriver                                 | SafariDriver                   | IEDriverServer                         | OperaDriver |
| 底层协议                 | Chrome DevTools Protocol (CDP)                          | Marionette Protocol                                          | CDP (Chromium内核)                                      | WebDriver协议 (内置)                         | JSON Wire Protocol (旧版)      | CDP (Chromium内核)                     |             |
| 官方支持                 | ✅ Google                                                | ✅ Mozilla                                                    | ✅ Microsoft                                             | ✅ Apple (仅MacOS)                            | ❌ 已停用                       | ❌ (社区维护)                           |             |
| 核心差异对比             | 启动示例（Python）                                      | driver = webdriver.Chrome()                                  | driver = webdriver.Firefox()                            | driver = webdriver.Edge()                    | driver = webdriver.Safari()    | driver = webdriver.Ie()                |             |
| 特殊配置需求             | 需下载匹配浏览器版本的ChromeDriver                      | 需GeckoDriver，推荐最新版本                                  | 需MSEdgeDriver（Chromium版）                            | 需在MacOS中启用「允许远程自动化」            | 需关闭IE保护模式，设置缩放100% |                                        |             |
| 兼容性与稳定性           | 兼容性                                                  | 最佳，支持最新Web标准                                        | 良好，但对部分CSS3/JavaScript支持滞后                   | 同Chrome（Chromium内核）                     | 仅限MacOS，对H5特性支持一般    | 仅支持旧版Web标准（如HTML4），稳定性差 |             |
| 常见问题                 | 版本必须与ChromeDriver严格匹配                          | GeckoDriver更新较慢                                          | 企业策略可能限制自动化                                  | 无法在Windows/Linux运行                      | 页面加载慢，易崩溃             |                                        |             |
| 性能对比                 | 执行速度                                                | 快                                                           | 中等                                                    | 快（同Chrome）                               | 慢                             | 极慢                                   |             |
| 资源占用                 | 高                                                      | 中等                                                         | 高                                                      | 低                                           | 高                             |                                        |             |
| Headless支持             | ✅ (--headless=new)                                      | ✅ (--headless)                                               | ✅ (--headless)                                          | ❌                                            | ❌                              |                                        |             |
| 特殊功能支持             | 跨域Cookie                                              | ✅                                                            | ✅                                                       | ✅                                            | ❌                              | ✅                                      |             |
| 文件下载管理             | ✅                                                       | ✅                                                            | ✅                                                       | ❌                                            | ❌                              |                                        |             |
| 移动设备模拟             | ✅（DevTools）                                           | ❌                                                            | ✅                                                       | ❌                                            | ❌                              |                                        |             |
| 截图全页                 | ✅                                                       | ✅                                                            | ✅                                                       | ❌                                            | ❌                              |                                        |             |
| 浏览器专属问题与解决方案 | 问题                                                    | 版本不匹配导致报错 This version of ChromeDriver only supports Chrome version xxx | GeckoDriver与Firefox版本兼容性问题                      | 版本不匹配导致报错                           | 默认禁用自动化                 | 页面元素无法交互                       |             |
| 解决                     | 可以使用webdriver-manager自动匹配驱动版本；手动更新版本 | 指定Firefox二进制路径                                        | 可以使用webdriver-manager自动匹配驱动版本；手动更新版本 | 手动开启：Safari菜单 → 开发 → 允许远程自动化 | 强制启用保护模式和缩放设置     |                                        |             |

**跨浏览器测试最佳实践**

​    1）统一使用WebDriver标准命令：避免浏览器专属的driver.execute_script()操作，优先使用W3C标准方法。

   2）优先选择Chromium内核浏览器：Chrome/Edge 在兼容性和性能上表现最佳，适合作为基准测试环境。

​    3）关键场景覆盖多浏览器：

[复制代码](自动化测试面试问答.md#)

```
browsers = [``"chrome"``, ``"firefox"``, ``"edge"``]``for` `browser in browsers:``  ``if` `browser == ``"chrome"``:``    ``driver = webdriver.Chrome()``  ``elif browser == ``"firefox"``:``    ``driver = webdriver.Firefox()``  ``# 执行通用测试脚本``  ``test_login(driver)``  ``driver.quit()
```

  4）使用云测试平台（如BrowserStack/Sauce Labs）：解决本地环境不足问题，支持旧版浏览器测试。

**如何选择浏览器？**

- 开发/调试：Chrome（DevTools强大）
- 生产测试：Chrome + Firefox（覆盖主流用户）
- 企业环境：Edge（兼容Windows策略）
- Mac用户：Safari（验证Apple生态兼容性）
- 旧系统支持：IE（仅限必要场景）

不同浏览器的差异要求测试脚本具备一定的适应性，建议通过 **Page Object Model (POM)** 封装浏览器相关逻辑，提升代码可维护性

#### 8、Xpath和CSS定位有什么不同？

| 特性           | XPath                                                        | CSS Selector                                                 |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 基本格式       | 基于XML路径语法（如/和//）                                   | 基于CSS样式规则（如.和#）                                    |
| 按ID定位       | //*[@id='username']                                          | #username                                                    |
| 按Class定位    | //*[contains(@class,'btn')]                                  | .btn-primary                                                 |
| 按属性定位     | //input[@name='email']                                       | input[name='email']                                          |
| 后代元素       | //div//span                                                  | div span                                                     |
| 直接子元素     | //div/span                                                   | div > span                                                   |
| 文本匹配       | //button[text()='Submit']                                    | 不支持（需结合JavaScript）                                   |
| 部分属性值匹配 | //input[contains([@id,'user')\]]()                           | input[id*='user']                                            |
| 第N个子元素    | //li[3]                                                      | li:nth-child                                                 |
| 优势           | 支持文本内容定位（如//*[text()='Login']）支持向上遍历DOM树（如//input/..找父节点）支持复杂逻辑表达式（如and、or） | 语法更简洁（特别是对class和ID）对伪类支持更好（如:hover、:checked） |

**适用场景推荐:**

| 场景                         | 推荐选择  | 理由                                                       |
| ---------------------------- | --------- | ---------------------------------------------------------- |
| 按ID/Class快速定位           | CSS       | 语法简洁（如#submit-btn比//*[@id='submit-btn']更直观）     |
| 需要匹配文本内容             | XPath     | CSS无法直接定位文本（如//button[contains(text(),'Save')]） |
| 动态生成的属性（如部分匹配） | 两者均可  | XPath的contains()或CSS的*=（如[id*='partial']）            |
| 复杂DOM层级遍历              | XPath     | 支持相对路径和轴（如following-sibling::）                  |
| 移动端测试（Appium）         | 优先XPath | 部分移动框架对CSS支持不完整                                |

#### 9、各种定位元素如：id，name，text，xpath......要怎么选择？

![img](./assets/D2B5CA33BD970F64A6301FA75AE2EB22-1753800997133-1.png)

- 黄金法则：ID > Name > CSS Selector > XPath > 其他。[**速度排名****（从快到慢）**]
- 动态元素：用contains、starts-with等部分匹配。
- 团队协作：统一约定定位策略（如优先用data-testid）。
- 终极目标：在稳定性、可读性和性能之间找到平衡！

#### 10、自动化测试web页面，怎么确保修改后的测试用例可以覆盖到关键的测试点？

 **Checklist**：关键测试点是否与需求文档一致？修改后的用例是否通过覆盖率工具验证？是否包含单元、集成、E2E 多层测试？断言是否覆盖成功/失败场景？是否加入回归测试套件？

| 具体方法                   | 步骤                                                         |                                                              |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1**.****需求与变更分析**   | 明确关键测试点                                               | 基于需求文档或用户故事，列出核心功能、高风险模块和用户常用路径（如登录、支付、数据提交等）。 |
| 变更影响分析               | 修改测试用例前，通过代码/需求变更记录识别受影响的功能模块（如使用git diff或需求管理工具）。 |                                                              |
| 2.**测试用例设计验证**     | 检查测试覆盖率                                               | 使用工具（如 Istanbul/JaCoCo 统计代码覆盖率，确保新增/修改的代码被测试覆盖。关键路径需达到 100% 行/分支覆盖率。示例：修改登录逻辑后，检查是否覆盖了新密码规则、错误处理等分支。 |
| 等价类与边界值             | 针对输入参数，明确有效/无效等价类和边界值（如输入框的字符长度、特殊字符处理） |                                                              |
| 3.**自动化测试层级的覆盖** | 分层测试策略                                                 | 单元测试：覆盖工具函数、组件逻辑（如 Jest 测试表单验证函数）。集成测试：验证组件交互（如 React Testing Library 测试登录组件与 API 的成）。E2E 测试：覆盖用户完整流程（如 Cypress 测试从登录到结账的流程）。 |
| 关键路径覆盖               |                                                              |                                                              |
| 4.**动态验证手段**         | 断言关键结果                                                 | 每个测试用例需包含明确的断言（如页面元素、API 响应、数据库状态）。 |
| 自动化回归套件             | 将修改后的用例加入回归测试，确保旧功能不受影响（如Jenkins 定时执行全量例）。 |                                                              |
| 5.**辅助工具与文档**       | 测试用例管理工具                                             | 使用TestRail/Zephyr 标记用例与需求的关联，确保每个需求有对应测试。 |
| 可视化覆盖率报告           | 生成并监控覆盖率报告（如pytest-cov或nyc的输出）。            |                                                              |
| 代码审查与配对             | 修改测试用例时，通过团队审查确认关键点覆盖（如GitHub PR Review）。 |                                                              |
| 6.**监控与反馈**           | 失败用例分析                                                 | 定期检查自动化测试失败日志，补充遗漏场景（如Sentry 捕获前端错误）。 |
| 生产环境监控               | 通过A/B 测试或实时监控（如New Relic）验证新功能是否按预期运行。 |                                                              |

[#自动化测试#]()[#selenium#]()[#测试#]()

作者：玖拾肆
链接：https://www.nowcoder.com/discuss/778615825879097344?sourceSSR=search
来源：牛客网