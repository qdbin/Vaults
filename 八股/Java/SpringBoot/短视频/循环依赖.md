### [Spring 循环依赖](https://v.douyin.com/St58S3wEK-M/)

> 重点：提前暴露，三级缓存  

#### 一、循环依赖介绍

- **定义**：两个或多个 Bean 之间相互依赖，形成闭环（如 A 依赖 B，B 依赖 A）。
- **问题表现**：Spring 创建 Bean 时，A 等待 B 初始化，B 又等待 A，导致死锁，抛出`BeanCurrentlyInCreationException`异常。

#### 二、Spring 的解决方案：三级缓存机制

1. **Spring有三个仓库，如下：**：
   - **一级缓存（成品库）**：存放完全初始化的 Bean。
   - **二级缓存（半成品库）**：存放已实例化但未完成属性注入的 Bean。（刚new完，但还没注入属性）
   - **三级缓存（工厂库）**：存放 Bean 的工厂（`ObjectFactory`），**用于延迟生成代理对象**。
2. **解决流程**：
   - Spring 创建 A 时，先将 A 的工厂放入三级缓存（这就是**提前暴露**）。
   - A 进行属性注入时发现需要 B，转而创建 B。
   - B 在属性注入时需要 A，按顺序查找缓存：
     - 一级缓存（未找到）→ 二级缓存（未找到）→ 三级缓存（找到 A 的工厂）。
   - B 通过工厂获取 A：
     - 若 A 需要代理，生成代理对象并注入 B；
     - 若不需要，直接返回原始 A。
   -  B 完成初始化后放入一级缓存，A 继续完成注入并放入一级缓存。

#### 三、为什么非要三级缓存，二级行不行？

##### 三级缓存的作用

> - 三级缓存（`singletonFactories`）存储的是`ObjectFactory`，即 Bean 的生成工厂。
> - 它的主要目的是延迟代理对象的创建，确保在需要时才生成代理。



- 三级缓存真正的价值，核心原因是**为了处理 AOP 代理与循环依赖的冲突**。

- 因为spring的生命周期，代理对象应该是再bean初始化后才生成，如果提前把代理对象放入二级缓存就相当于破坏了生命周期，如果只放原始对象那bean注入的就是假a

- 三级缓存的精髓就在这里，他存货的提货单让spring把是否要创建代理的这个决定延迟到了真正发生循环依赖的那一刻

  > 没有循环依赖，a就走完了所有流程在最后一步安安稳稳生成代理对象，安安稳稳被代理，符合标准生命周期，一旦发生循环依赖，b提前要a，三级缓存的提货单才会被调用，这个时候才会检查a的情况，发现它需要被代理，然后立刻生成一个代理对象，这样b拿到就是正确代理a，

- **这种延迟策略让spring避免了把所有bean的代理逻辑提前，破坏生命周期也只发生在代理+循环依赖这种小范围场景**

- 若仅用二级缓存：
  - 直接放入代理对象会破坏 Spring 生命周期（代理应在初始化后生成）。
  - 放入原始对象会导致 B 注入的是未代理的 A（“假 A”）。
- 三级缓存的工厂机制允许延迟决策：
  - 无循环依赖时，A 按正常流程生成代理；
  - 有循环依赖时，B 通过工厂动态生成代理对象，确保依赖正确。

#### 四、面试常见问题

1. ##### 循环依赖失效的场景有哪些？

   - **全构造器注入**：Bean 实例化时需完整参数，无法提前暴露（

     > 这个时候bean没有创建实例，自然也没有对应工厂bean，全是构造器注入，spring无法处理循环依赖

   - **原型作用域（Prototype）**：每次请求创建新实例，导致无限递归。（导致栈溢出）

2. ##### 除了spring的三级缓存之外，还有哪些可以解决循环依赖的问题？

   1. **重构设计**：避免循环依赖，从根本上解决问题（推荐）。

   2. **使用@Lazy 注解**：延迟一方的注入，打破即时依赖。

3. ##### Spring Boot 2.6 后，为什么默认禁止循环依赖？

   - 因其可能会破坏 Bean 生命周期，需手动配置才可以

#### 五、总结

- 循环依赖本质是 Bean 相互等待，Spring 通过三级缓存和延迟代理解决。
- 三级缓存的核心价值在于平衡 AOP 代理与生命周期，仅在必要时生成代理。
- 面试需注意失效场景、替代方案及 Spring Boot 的新策略。



### 视频原话

#### **1. 循环依赖的定义**

> “说白了就是你中有我，我中有你。你看这段代码，A 类要注入 B，B 类又要注入 A。Spring 在创建 A 的时候一看，我需要 B，于是它就跑去创建 B。创建 B 的时候又一看，我需要 A。可问题是 A 连自己都还没整明白，它还在那儿等着 B，这不就卡住了吗？俩人搁这儿互相谦让，结果就是死锁，程序直接给你抛异常。”

#### **2. Spring 解决循环依赖的核心方案**

> “聪明的 Spring 是怎么解决死结的？记住八个字：**提前暴露，三级缓存**。Spring 有三个仓库，一级缓存成品库，二级缓存半成品库，三级缓存。关键来了，放的不是 Bean，而是提货单（工厂）。”

#### **3. 三级缓存的实战流程**

1. 创建 A 并提前暴露

   > “Spring new 出 A，放了个提货单进三级缓存，这就是提前暴露。”

2. A 属性注入时需要 B

   > “A 开始精装修（属性注入），发现要 B，于是去造 B。”

3. B 属性注入时需要 A

   > “B 装修时又发现要 A，这时候就去仓库里找了。先去一级缓存（成品仓）找，没找到再去二级缓存（半成品仓）找，还没找到。最后在三级缓存里找到了那张 A 的提货单，B 立刻就拿着提货单去提货了。”

4. 提货逻辑（处理 AOP 代理）

   > “提货的过程非常智能，它会检查一下 A 需要被代理吗？如果需要就立刻生成代理对象给你，不要就返回原始 A，B 就注入成功 A 了。装修完放进一级缓存。”

5. A 完成注入并放入一级缓存

   > “回到 A 这里，它需要的 B 已经准备好了。直接注入，A 也精装修完毕，最终也放进了一级缓存。”

#### **4. 三级缓存的核心价值（处理 AOP 代理）**

> “三级缓存真正的价值是为了处理 AOP 代理！因为按照 Spring 的生命周期，代理对象应该在 Bean 初始化后才生成，所以如果你直接把代理提前放二级缓存就破坏了生命周期。如果只放原始对象，那 B 注入到的又就是假 A。所以三级缓存的精髓就在这里！它存放的提货单让 Spring 把是否要创建代理这个决定延迟到了真正发生循环依赖的那一刻。”

#### **5. 常见面试题**

**问题 1：什么情况下循环依赖会失效？**

> “1. 全是构造器注入。你想 newA (b) 的时候，A 的毛坯房都还没建好，上哪儿去给你提前暴露，new B (a) 就直接 GG 了。所以全是构造器注入，Spring 无法处理循环依赖。2. 原型作用域。也就是循环依赖的 Bean 是原型模式，每次都要新的 Bean，A 要新 B，B 要新 A，A 要新 B，无限套娃，直接栈溢出。”

**问题 2：除此之外还有哪些手段可以解决循环依赖问题？**

> “常见有两种：1、重新设计，避免循环依赖从根本上解决问题。2、使用 @Lazy 注解，延迟一方的注入打破了即时依赖。”

**问题 3：Spring Boot2.6 之后为什么默认禁止循环依赖？**

> “因为它确实会破坏 Bean 生命周期，所以默认 ban 掉，要自己开配置才行。”

#### **总结**

> “通过这三级缓存的完美配合，这个死结不就解开了吗？”