[原来数据库事务是这样的](https://www.bilibili.com/video/BV17qKbzGEW7?vd_source=a3edfa2588cde0dbe42d7192afacee48)

### 事务是什么？

- 数据库的事务就是**一系列sql语句构成逻辑上的整体**



### 事务并发存在问题

1. **脏读：**

- 一个事务读取到另外一个事务没有提交的数据
- 比如：tran1修改库存0变为1，但没有提交，tran2读到库存1进行操作，但tran1回滚为0，tran2则出错

2. **不可重复读：**

- 同一个事务中前后两次的数据不一致，就是不可重复读

3. **幻读：**

- 比如：tran1范围查询有10条数据，tran2插入20条数据，tran1再次范围查询，发现有30条数据

4. **不可重复读和幻读区别**

- 前者强调的是多次读取的数据不一样，幻读强调的是数据条数的一个增减





### ACID（原子性，一致性，隔离性，持久性）

#### 原子性：

- 比如：转账场景，a-100，b+100,要么都成功，要么失败都回滚，不应存在一个成功一个失败的中间态

- 实现：通过`undo log` 回滚日志实现，n个连续sql失败一个则通过`undo log`给前面操作全部回滚


#### 持久性：

- 只要数据提交，无论发生什么事情，数据库的修改都不会丢失
- 实现：通过`redo log`，每次事务提交把修改写入`redo log`，即便mysql数据没有持久化到磁盘中，也能读取`redo log`来恢复数据，`redo log`保证了事务的持久性，这也就是为什么说`redo log`让mysql有了崩溃恢复的能力
- redo log本身也要持久化到磁盘的，mysql崩了，redo log刷盘失败数据就丢了？（后面细说）

#### 隔离性：

- 情景：事务1修改，事务2脏读，读到事务1修改的数据，然后修改，事务1回滚，就导致出现问题

- 在并发执行事务时，多个**事务应相互隔离**，互不影响
- 实现：MVCC+锁，配合undo log实现（后面详细说）

#### 一致性：

- 如转账，无论是否成功，转账人和收款人的钱的总数是保持不变的
- 实现：只要保证了原子性，持久性，隔离性自然可以





### 隔离级别

#### 读未提交

- 最低级别，实际不会用
- **每个事务都能看到其他事务未提交的数据**
- 不能解决脏读，不可重复读，幻读的问题

#### 读已提交

- **每个事务只能读到其他事务已提交的数据**
- 可以解决脏读问题，但无法解决不可重复读和幻读

#### 可重复读

- mysql的一个默认的隔离级别
- **第一次读的时候会生成一份数据快照**，其他事务的修改，对当前事务是不可见的，从而使用快照，两次读到的数据是一样的
- 解决不可重复读的问题，但无法解决幻读问题

#### 串行化

- mysql最高的一个隔离级别
- **串行化要求的事务不能并发执行**，只能一个个的顺序串行执行，无法并发执行自然不存在并发问题
- 虽然可以解决所有并发问题但性能很差，并发量高的情况会导致大量的超时和锁竞争，通常不会用

事务的隔离级别越高越能保证数据的一致性和完整性，执行效率也越低，反之，级别越低效率越高，一致性越差



#### 不同隔离级别怎么实现？

读未提交不用实现，多个并发事务同时执行天然就是读未提交，但是写的时候还是要加锁

**串行化**：加锁，只有拿到锁的事务才能执行

**可重复读**：

- 每次会读到和第一次相同的数据快照，即使其他数据修改也不会受其影响
- 第一次select会生成一个`read view`，判断数据版本对当前事务是否可见，可重复读每次都会复用第一次生成的`read view`
- 也就是说生成`read view`的时候，哪些版本的数据对当前事务可见就固定下来了，后续通过同一个`read view`判断数据的可见性，能看到的数据版本都是一样的，故每次都读同一个数据版本
  - 总结：通过MVCC快照读即复用`read view`，再加上当前读加锁的方式，从而避免大多数幻读（无法避免快照读再当前读的问题）


**读已提交**：

- 事务只能读取到其他事务已经提交的数据
- 其本质就是每次select就生成一个新的`read view`，那每次都能读到最新的已经提交的数据版本
- 总结：可重复读通过MVCC实现

#### MVCC简单说明

> MVCC基本思想（多版本并发控制）
>
> 维护数据的多个版本（某个数据，每个事务的修改都会新增个版本），具体读取哪个版本取决`read view`,执行select会生成快照`read view`，**`read view`主要用来判断数据版本对当前事务的可见性**，可以在一堆版本中找到哪个版本对当前事务的可见的，就可以找到并把这个版本的数据返回