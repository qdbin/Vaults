# 计算机网络

## 计算机网络体系结构

### OSI七层模型
   > 物理层，数据称为**⽐特流**；数据链路层，数据称为**帧**；⽹络层，数据称为**包**；在传输层，数据称为**段**；
1. **应用层：**最靠近用户的层，**负责处理特定的应用程序细节**。这一层提供了网络服务与用户应用软件之间的接口。例如，Web 浏览器、FTP 客户端和服务器、电子邮件客户端等。

2. **表示层：**确保从一个系统发送的信息可以被另一个系统的应用层读取。它**负责数据的转换、压缩和加密**。例如，确保数据从一种编码格式转换为另一种，如 ASCII 到 EBCDIC。

3. **会话层：**管理用户的会话，控制**网络上两节点间的对话和数据交换的管理**。它负责**建立、维护和终止会话**。例如，建立一个会话令牌，以便在网络上的两个节点之间传递。

4. **传输层：**提供**端到端的通信服务**，保证**数据的完整性和正确顺序**。这一层包括 TCP 和 UDP 等。

5. **网络层：**负责在**多个网络之间进行数据传输**，确保数据能够在复杂的网络结构中找到**从源到目的地的最佳路径**。这层使用的是 **IP**（Internet Protocol）协议。

6. **数据链路层：**在**物理连接中提供可靠的传输**，负责**建立和维护两个相邻节点间的链路**。包括**帧同步**、MAC（媒体访问控制）。

7. **物理层：**负责在**物理媒介上实现原始的数据传输**，比如**电缆、光纤和无线信号传输**。涉及的内容包括电压、接口、针脚、电缆的规格和传输速率等。





### TCP/IP四层模型

#### 1. 应用层

包括所有和网络有关的高级协议、HTTP、FTP、SMTP

#### 2. 传输层

负责端到端数据传输服务，包括数据分割、流量控制和错误恢复，TCP、UDP协议

#### 3. 网际层

主要协议IP负责数据包的寻址和路由

#### 4. 网络接口层

负责数据帧的物理传输，包括硬件地址寻址（MAC），数据封装和解封装，错误检测和纠正



### 五层结构

#### 1. 应用层

网络服务和最终用户之间的接口，提供一系列供应用程序使用的协议，如HTTP、FTP等，使用户的应用程序可以访问网络服务

#### 2. 传输层

提供进程到进程的通信管理，确保数据按顺序、无错误的传输，TCP和UDP

#### 3. 网络层

负责数据包从源目的地的传输和路由选择，包括跨越多个网络，使用逻辑地址来表示唯一设备

#### 4. 数据链路层

确保从一个节点到另一个节点可靠、有效的数据传输

#### 5. 物理层

电缆、光纤、网络适配器等



## 网络综合

### 浏览器地址栏输入url到显示主页过程

1. **DNS 解析：**浏览器发起一个 DNS 请求到 DNS 服务器，将域名解析为服务器的 IP 地址。
2. **TCP 连接：**浏览器通过解析得到的 IP 地址与服务器建立 TCP 连接（通常是通过 443 端口进行 SSL 加密的 HTTPS 连接）。这一步涉及到 TCP 的三次握手过程，确保双方都准备好进行数据传输。
3. **发送 HTTP 请求：**浏览器构建 HTTP 请求消息，包括请求行（如 GET / HTTP/1.1）、请求头（包含用户代理、接受的内容类型等信息）和请求体（如果有）；将请求发送到服务器。
4. **服务器处理请求：**服务器接收到 HTTP 请求后，根据请求的资源路径，经过后端处理（可能包括数据库查询等），生成 HTTP 响应消息；响应消息包括状态行（如 HTTP/1.1 200 OK）、响应头（内容类型、缓存控制等信息）和响应体（请求的资源内容）。
5. **浏览器接收 HTTP 响应：**浏览器接收到服务器返回的 HTTP 响应数据，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。
6. **断开连接：**TCP 四次挥手，连接结束

### DNS解析过程

1. **浏览器检查缓存、HOST文件**中是否有域名对应的IP地址，有就直接返回
2. **检查本地DNS缓存**是否有该域名的记录，没有就向**根域名服务器**发送请求
3. 根域名服务器将请求指向更具体服务，返回**顶级域名服务器**
4. 顶级域名服务器再将请求指向**权限域名服务器**返回对应ip地址
5. **浏览器使用**获得的ip地址发起一个HTTP请求到目标服务器



## TCP

### 三次握手

#### 第一次握手：SYN（起初都是CLOSE，之后服务器进入LISTEN）

1. 发起连接：客户端发送一个 TCP 报文段到服务器。这个报文段的头部中，SYN 位被设置为 1，表明这是一个连接请求。同时，客户端会随机选择一个序列号（Sequence Number），假设为 x，发送给服务器。

2. 目的：客户端通知服务器它希望建立连接，并告知服务器自己的初始序列号。
3. 状态：客户端进入 SYN_SENT 状态。

#### 第二次握手：SYN+ACK

1. 确认并应答：服务器收到客户端的连接请求后，如果同意建立连接，它会发送一个应答 TCP 报文段给客户端。在这个报文段中，SYN 位和 ACK 位都被设置为 1。服务器也会选择自己的一个随机序列号，假设为 y，并将客户端的序列号加 1（即 x+1）作为确认号（Acknowledgment Number），发送给客户端。

2. 目的：服务器告诉客户端，它的连接请求被接受了，并通知客户端自己的初始序列号。
3. 状态：服务器进入 SYN_RCVD 状态。

#### 第三次握手：ACK

1. 最终确认：客户端收到服务器的应答后，还需要向服务器发送一个确认。这个 TCP 报文段的 ACK 位被设置为 1，确认号被设置为服务器序列号加 1（即 y+1），而自己的序列号是 x+1。
2. 目的：客户端确认收到了服务器的同步应答，完成三次握手，建立连接。
3. 状态：客户端进入 ESTABLISHED 状态，当服务器接收到这个包时，也进入 ESTABLISHED 状态

### 为什么不是两次/四次握手

1. 两次的话：服务端回复的syn+ack如果丢失，不知道客户端是否接收就会始终等待客户端发送数据；服务端可能会接收到客户端以前延误发送的连接，但其实后来已经重新建立了。如果是两次，服务器还会错误开启一个不再需要的连接

2. 三次已经足够建立可靠的，没必要多握一次


### 四次挥手

数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起
客户端发送释放连接报文，第一次挥手 (FIN=1，seq=u)，发送完毕后，客户端进入 FIN_WAIT_1 状态。
服务端发送确认报文，第二次挥手 (ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态。
服务端发送释放连接报文，第三次挥手 (FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。
客户端发送确认报文，第四次挥手 (ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。

#### 为什么挥手需要四次

关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。

#### 为什么需要等待2MSL，才进入CLOSE

为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。 这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的服务端就收不到对已发送的 FIN + ACK 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 CLOSED 状态。
防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。

### TCP如何保证可靠性

#### 连接管理

三次握手和四次挥手保证可靠的建立连接和释放连接

#### 校验和

TCP保持首部和数据的校验和，这是端到端的校验和，检测数据在传输过程中任何变化，如果接收端校验和有差错，TCP丢弃这个报文段并不确认收到此报文段

#### 序列号/确认应答

TCP给发送的每一个包进行编号，接收方对收到的包进行应答，发送方就会知道接收方是否收到对应包，没收到就重发，保证数据完整性

#### 流量控制

TCP连接每一方都有固定大小缓冲空间，接收端只允许发送端发送接收端能接纳的数据，当接收方来不及处理发送方数据，就会提示其降低发送速率

TCP流量控制协议是可变大小的滑动窗口协议

#### 最大消息长度

建立TCP连接时，双方约定一个最大长度MSS作为发送单位，重传是也以这个单位进行重传

#### 超时重传

设定发送出去的数据包到接收到确认包之间的时间，超过了这个时间认为是丢包了，需要重传

#### 拥塞控制

如果网络非常拥堵，可能发送的数据段超过最大生存时间也没到接收方。TCP引入慢启动机制，先发少量数据，了解当前网络拥堵状态后，再决定按照多大速度传送数据

### TCP流量控制

TCP流量控制让发送端根据接收端实际接收能力控制发送的数据量。
TCP通过滑动窗口控制流量，发送方给接收方发送了一定字节数据，发送方的可用窗口就减少，接收方收到后放在缓冲队列，再把缩小后的滑动窗口长度返给发送方。

当接收窗口为0，发送方停止发送，开启一个定时任务，每隔一段时间就去询问接收方，直到接收方有可用窗口

### TCP拥塞控制

发送方维护一个拥塞窗口的变量，调节所要发送的数据量
拥塞窗⼝ cwnd是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。
发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。

拥塞窗⼝ cwnd 变化的规则：
只要⽹络中没有出现拥塞， cwnd 就会增⼤；
但⽹络中出现了拥塞， cwnd 就减少；

#### 常用算法

##### 慢启动

它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）。每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。

为了防止 cwnd 增长过大引起网络拥塞，还需设置一个慢启动阀值 ssthresh（slow start threshold）状态变量。当cwnd到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 cwnd >ssthresh 时，进入了拥塞避免算法。

##### 拥塞避免

一般来说，慢启动阀值 ssthresh 是 65535 字节，cwnd到达慢启动阀值后

每收到一个 ACK 时，cwnd = cwnd + 1/cwnd
当每过一个 RTT 时，cwnd = cwnd + 1
显然这是一个线性上升的算法，避免过快导致网络拥塞问题。

##### 拥塞发生

当网络拥塞发生丢包时，会有两种情况：
RTO 超时重传
快速重传
如果是发生了 RTO 超时重传，就会使用拥塞发生算法
慢启动阀值 sshthresh = cwnd /2
cwnd 重置为 1
进入新的慢启动过程

其实还有更好的处理方式，就是快速重传。发送方收到 3 个连续重复的 ACK 时，就会快速地重传。
发⽣快速重传的拥塞发⽣算法：
拥塞窗口大小 cwnd = cwnd/2
慢启动阀值 ssthresh = cwnd
进入快速恢复算法

###### RTO重传

###### 快速重传

##### 快速恢复

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：
cwnd = cwnd /2
sshthresh = cwnd
然后，进⼊快速恢复算法如下：
cwnd = sshthresh + 3
重传重复的那几个 ACK（即丢失的那几个数据包）
如果再收到重复的 ACK，那么 cwnd = cwnd +1
如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。

### TCP重传机制

#### 超时重传

超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。

超时时间RTO要略大于RTT也就是数据包一次往返的时间

#### 快速重传

发送⽅发出了 1，2，3，4，5 份数据：

第⼀份 Seq1 先送到了，于是就 Ack 回 2；
结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；
后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；
发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。
最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6

仍面临重传问题，是重传1个还是后面所有

#### 带选择确认的重传（SACK）

SACK 机制就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。
发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。

#### 重复SACK

是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。

DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。

比如接收方发送给发送方的两个ACK确认应答都丢失了，发送方超时重传第一个后，接受发现收到数据重复，就会回一个sack告知数据早已被接受，并通过ACK告知已经收的数据

## UDP

### TCP和UDP区别

TCP面向连接，UDP不是
TCP传输可靠，UDP不是
TCP字节流传输，UDP数据段报文传输
TCP传输效率慢，UDP快
TCP应用于文件、邮件传输，UDP应用于即时通讯
TCP首部20-60字节，UDP8字节

### UDP如何保证消息不丢失

对于 TCP 协议来说，如果数据包在传输过程中丢失，TCP 协议会自动进行重传。

而对于 UDP 协议来说，我们可以通过应用层的重传机制来保证消息的不丢失。当接收方收到消息后，返回一个确认信息给发送方，如果发送方在一定时间内没有收到确认信息，就重新发送消息。

同时，每个消息都附带一个唯一的序列号，接收方根据序列号判断是否有消息丢失，如果发现序列号不连续，就可以要求发送方重新发送。这样还可以防止消息重复。

当然了，消息持久化也很重要，可以将消息保存在服务器或者本地的数据库中，即使在网络中断或者其他异常情况下，也能从数据库中恢复消息。

## IP

### IP协议作用

寻址和路由：在 IP 数据报中携带源 IP 地址和目的 IP 地址来表示该数据包的源主机和目标主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至目标主机。
分段和重组：IP 数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP 协议通过给每个 IP 数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的 IP 数据报。

### ARP协议工作过程

①、ARP 请求
当主机 A 要发送数据给主机 B 时，首先会在自己的 ARP 缓存中查找主机 B 的 MAC 地址。
如果没有找到，主机 A 会向网络中广播一个 ARP 请求数据包，请求网络中的所有主机告诉它们的 MAC 地址；这个请求包含了请求设备和目标设备的 IP 和 MAC 地址。

②、ARP 应答
网络中的所有主机都会收到这个 ARP 请求，但只有主机 B 会回复 ARP 应答，告诉主机 A 自己的 MAC 地址。
并且主机 B 会将主机 A 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中，以便下次通信时直接使用。

③、更新 ARP 缓存
主机 A 收到主机 B 的 ARP 应答后，也会将主机 B 的 IP 和 MAC 地址映射关系缓存到自己的 ARP 缓存中。

## HTTP

### GET和POST区别

报文层面
GET请求将信息放在URL，post放在请求体，get携带数据量有限，post对大小无限制，get放在url上不太安全
数据库层面
get符合幂等性和安全性，post不符合，get用于查看信息，不改变服务器上信息，post请求用来改变服务器上信息
其他层面
get请求能被缓存，保存在浏览器的浏览记录，get请求的url能保存为书签，post不能

### HTTP报文结构

请求报文
	请求行
	请求头部
	空行
	消息正文（可选）
响应报文
	状态行
	响应头部
	空行
	消息正文（可选）

#### 请求报文

##### 请求行

方法（GET、POST），请求的URL和HTTP协议版本

##### 请求头部

请求的附加信息，如客户端想要接受的内容类型、浏览器类型

##### 空行

##### 消息正文（可选）

#### 响应报文

##### 状态行

HTTP协议版本，状态码和状态消息

##### 响应头部

响应的附加信息如服务器类型、内容类型和内容长度

##### 空行

##### 消息正文（可选）

### HTTPS工作流程

①、客户端向服务器发起请求
②、服务器接收到请求后，会返回自己的数字证书，包含了公钥、颁发机构等信息。
③、客户端收到服务器的数字证书后，会验证证书的合法性，如果合法，就会生成一个随机码，然后用服务器的公钥加密这个随机码，发送给服务器。
④、服务器收到会话密钥后，用私钥解密，得到会话密钥。
⑤、客户端和服务器通过会话密码对通信内容进行加密，然后传输。
如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。
HTTPS 在不同阶段会使用不同的加密方式：

### Session和Cookie

#### session

Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 session。客户端浏览器再次访问时只需要从该 session 中查找用户的状态。

#### cookie

Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个 Cookie 判断用户的身份和状态。

#### cookie和session的区别

存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。
存储数据类型不一样，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。
有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。
隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。
存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。

### 状态码

1XX提示信息（协议处理的中间状态）
2XX成功
	200 一切正常，如果是非HEAD请求，服务器返回响应头带有body数据
	204正常，与200基本相同，但响应头没有body数据
	206应用于HTTP分块下载或断点续传，相应返回的body数据是资源的一部分
3XX重定向
	301永久重定向，请求资源不在，改用新的URL访问
	302临时重定向，请求资源还在，暂时需要用另一个URL访问
	304不具备跳转含义，资源未修改，重定向已存在的缓冲文件，客户端可以继续用缓存
4XX客户端错误
	400客户端请求报文有错，很笼统
	403服务器禁止访问资源，并不是客户端请求出错
	404请求资源在服务器上不存在或未找到
5XX服务器错误
	500笼统的错误码
	501客户端请求的功能还不支持
	502服务器作为网关或代理时返回的错误码，服务器自身正常，访问后端服务器发生了错误
	503服务器当前很忙，暂时无法响应
