### 简述

索引本质就是一种数据结构（常为B+树），从而高效获取数据

- 常规二叉树，对其增加可能会形成单向链表，层级过深
- 平衡二叉树虽然解决层级过深问题，但依旧存在层级过深问题
- B树又没有解决数据获取的不稳定性，且对范围区间的查找需要多次查找
- B+树，数据存储全部在叶子结点，分叉结点专注存储key，实现一个结点更多分叉，实现扁平化，且叶子结点间使用双向链表，便于区间查找，稳定查找效率

#### 重点

- 索引常规要考虑支持范围查询（支持排序）
- 增删改会更新索引是否有有影响

### [核心机制和应用](https://www.bilibili.com/video/BV1MNNtzHEPF?vd_source=a3edfa2588cde0dbe42d7192afacee48)

#### 使用哪种数据结构做索引？

- **哈希表**：O(1）快，但是没办法做范围查询也不能排序
- **二叉排序数**：**中序遍历是有序**，**可以范围查询**，但**顺序插入会退化为链表**，性能很差
- **平衡二叉树**：插入结点旋转二叉树保持平衡，**增删数据会频繁左右旋转结点调整**，会大量IO降低性能
- **红黑树**：类似平衡树**不追求绝对平衡**，降低插入删除旋转的操作，但一个一个结点只有两个孩子，大量数据，会导致树高，**查找性能会直接和树高挂钩**，红黑树适合存储少量数据的内存操作
- **b树**（多路平衡排序树）：一个结点有多个孩子，降低树高，但b树又存data又存index_value，导致b树一个结点存不了多少索引，**不能通过中序遍历使其有序**，**不能做范围查询**，需要回溯整个树结构，效率比较低会产生**随机IO，查询效率不稳定**
- **b+树**：数据均放到**叶子结点并使用双向链表连接**，**非叶子结点只存索引值**，可以提升分叉路，降低树的高度，**解决范围查询，只需遍历链表即可无需回溯树结构**，性能更好，也是mysql保存索引的最好数据结构

#### B+树通常怎么存储数据？

- 提示：答两种索引存储结构

- 索引从存储结构上主要分为两种：**聚集索引和非聚集索引**（别名，聚簇索引和非聚簇索引），本质就是**索引值和数据一块存还是分开存**
- **主键索引就是聚集索引**，非叶子结点都是索引值，**叶子结点使索引值及其行数据**，在b+树种，**主键应自增插入**，否则，如果**不自增就会导致页分裂带来的性能问题**
- 唯一索引，普通索引，前缀索引就是**二级索引（或者叫非聚集索引）**，非叶子结点存储索引值，**叶子结点存储索引值和对应的主键id**（故此二级索引是根据列索引查找自己的索引树，得到主键id，从而二次查找主键索引树从而查出行数据，这个过程叫回表，回表会降低查询效率）

#### 查二级索引一定会回表吗？

- 不一定，如果只为得到id，二级索引的叶子结点就有id，则不用回表
- 当一个索引包含所有需要查询字段值的时候，则无需回表，这种情况也就是覆盖索引，故**为减少回表查询，要尽可能做到覆盖索引查询**，如：`联合索引（id,name）:select id,name from tb where id=001`就会避免回表
- 如果一个索引列有多个字段，那就能大大增加覆盖索引概率，也就是**联合索引**（根据多个字段创建索引），避免使用`select *`容易触发回表

#### 你提到联合索引，那讲一下最左匹配法则吧

- 联合索引**因为有多个索引列**，所以**排序会根据索引列的顺序去排**，查找会根据**索引列的顺序从左到右依次匹配**，如`索引（a,b,c）`,若a不存在，bc就是乱序，ab不存在c也是乱序的，无法跳过前面的索引列去匹配，必须从左到右依次使用索引列匹配，如`where b=xx and a=xx`**mysql的优化器会自动重排索引列**，所以查询字段筛选顺序可与索引列顺序不一样。如：`where a=xx and c=xx`a会走索引，c无法走索引

#### 讲一下其他索引失效的场景

- 比如查询字符串，`where name like %斌%`**头部模糊**，索引就失效了，从左往右匹配，左边没有数据没有办法搜索匹配
- 索引列运算，**函数运算也会让索引失效**，因为b+树存的是索引值，**计算后无法确定在B+树中的位置了**
- 在做**隐形类型转换的时候**，也会让索引失效，**其会触发cast函数**，去做转换，间接调函数处理了
- 在用**or的时候出现了非索引列**，那就没办法走索引了，**不能同时做索引扫描和全表扫描**，故直接退化为全表扫描，and不会失效但会回表（个人认为）
- 索引失效有很多，只要理解索引查找的基本原理就都能明白
- ![image-20250911061014204](assets/image-20250911061014204.png)

#### 那索引这么快全部加上索引不就好了？

- 索引就像字典的目录，**过多索引会导致目录越来越多，占用空间越来越大**，如果目录空间都赶上正文，那要正文自然就就没用了
- 索引不是越来越多越好，且会讲到增删改的性能，你**增删改的操作也会对应更新对应索引，若索引过多会导致性能下降**，索引自然不是越多越好（增加IO操作导致性能降低）

#### 应该怎么加索引比较好？

- 数据量大的，查询频繁的就适合加索引，**经常 `where,group by,order by` 的列适合加索引**，**增删改频繁的列就不适合加索引**，**区分度高的列也比较适合做索引**（身份证号适合，性别不适合），**比较长的字符串可以使用前缀索引**
- **尽可能多的用联合索引**而不是单列索引，联合索引可以覆盖索引，**避免回表，提升效率**
- 一张表的**索引不能太多**，最多不能超过5个，不然大大降低插入和删除的效率

#### 怎么知道要不要加索引？

#### 怎么判断一个sql是否走了索引？

- 可以看**mysql的慢查询日志**，可以查看执行时间和超过阈值的所有查询语句，从而找到慢sql
- 也可以**使用explain执行计划对慢sql进行分析**，查询是否走了索引，走了什么索引，针对优化即可

![image-20250911063601955](assets/image-20250911063601955.png)

### 小疑问

索引有哪些类型，有哪些extra？



### 随记要点

- 索引字段不能进行任何计算，否则就会失效

```sql
# 使用explain可以查看解释sql语句的具体相关信息（索引匹配类型（range范围，ref值引用），索引名等等）
explain
select * from student id='001'

```

### SQL示例

```sql
# 创建索引
create index idx1 on tb1(i,dt)	
# 不存在性能问题，此次索引会支持反向索引扫描，从而对结果进行排序
select * from tb1 where id=99
order by dt desc
limit 5;


# 创建索引
create index idx1 on tb(c1,c2)	
# 存在性能问题，不符合索引最左匹配原则，需要先匹配c1才能匹配c2
select * from tb where c2=99


# 创建索引
create index idx1 on tb(str_column)	
# 存在性能问题，索引是从前到后匹配的，内容一开始都不知道内容自然会索引失效
select * from tb where str_column=%hanbin%
```

### 其他问题补充

#### 索引有哪些优缺点

![image-20250911064034764](assets/image-20250911064034764.png)

#### 什么是回表，如何减少回表？

![image-20250911061627863](assets/image-20250911061627863.png)

### 什么是覆盖索引？

- 简单说就是，查询列要被所建的索引覆盖

![image-20250911061810717](assets/image-20250911061810717.png)

#### 什么是索引下推？

- 简单说就是mysql5.6版本之前，会在索引树先根据满足条件的一个索引列，通过二级索引先拿到主键id，回表找出对应数据行，再去对比剩余字段，从而减少数据行
- mysql5.6版本之后，进行优化，会对所有中的值先判断，如果有多个索引列，则一起索引查询

![image-20250911062514692](assets/image-20250911062514692.png)

#### 大表A如何添加索引？

- 简单说就是创建个大表A的副本表结构B，然后导入大表A数据，然后修改副本表B为大表A的名即可

![image-20250911063249805](assets/image-20250911063249805.png)

#### Hash索引和B+树区别？你在设计索引怎么抉择？

![image-20250911063853764](assets/image-20250911063853764.png)

#### 聚簇索引和非聚簇索引的区别

![image-20250911064313199](assets/image-20250911064313199.png)

